#!/usr/bin/env python3
"""
Unit tests for vulnerability-mgmt/prioritization/risk-scorer.py
"""

import json
import sys
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime, timedelta

import pytest

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from vulnerability_mgmt.prioritization.risk_scorer import RiskScorer


class TestRiskScorerInit:
    """Test RiskScorer initialization"""

    def test_init_basic(self):
        """Test basic initialization"""
        scorer = RiskScorer()

        assert scorer.kev_catalog is None
        assert isinstance(scorer.epss_data, dict)

    def test_init_attributes(self):
        """Test initialization attributes"""
        scorer = RiskScorer()

        assert hasattr(scorer, 'kev_catalog')
        assert hasattr(scorer, 'epss_data')


class TestKEVCatalogLoading:
    """Test KEV (Known Exploited Vulnerabilities) catalog loading"""

    @patch('vulnerability_mgmt.prioritization.risk_scorer.requests.get')
    def test_load_kev_catalog_success(self, mock_get):
        """Test successful KEV catalog loading"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {'cveID': 'CVE-2021-44228', 'vendorProject': 'Apache'},
                {'cveID': 'CVE-2021-45046', 'vendorProject': 'Apache'}
            ]
        }
        mock_get.return_value = mock_response

        scorer = RiskScorer()
        result = scorer.load_kev_catalog()

        assert result is True
        assert scorer.kev_catalog is not None
        assert len(scorer.kev_catalog['vulnerabilities']) == 2

    @patch('vulnerability_mgmt.prioritization.risk_scorer.requests.get')
    def test_load_kev_catalog_failure(self, mock_get):
        """Test KEV catalog loading failure"""
        mock_response = Mock()
        mock_response.status_code = 404
        mock_get.return_value = mock_response

        scorer = RiskScorer()
        result = scorer.load_kev_catalog()

        assert result is False

    @patch('vulnerability_mgmt.prioritization.risk_scorer.requests.get')
    def test_load_kev_catalog_timeout(self, mock_get):
        """Test KEV catalog loading with timeout"""
        mock_get.side_effect = TimeoutError("Request timeout")

        scorer = RiskScorer()
        result = scorer.load_kev_catalog()

        assert result is False

    @patch('vulnerability_mgmt.prioritization.risk_scorer.REQUESTS_AVAILABLE', False)
    def test_load_kev_without_requests_library(self):
        """Test loading KEV when requests library unavailable"""
        scorer = RiskScorer()
        result = scorer.load_kev_catalog()

        assert result is False


class TestKEVCheck:
    """Test KEV catalog checking"""

    def test_check_kev_vulnerability_exists(self):
        """Test checking if CVE is in KEV catalog"""
        scorer = RiskScorer()
        scorer.kev_catalog = {
            'vulnerabilities': [
                {'cveID': 'CVE-2021-44228', 'vendorProject': 'Apache'},
                {'cveID': 'CVE-2021-45046', 'vendorProject': 'Apache'}
            ]
        }

        result = scorer.check_kev('CVE-2021-44228')
        assert result is True

    def test_check_kev_vulnerability_not_exists(self):
        """Test checking CVE not in KEV catalog"""
        scorer = RiskScorer()
        scorer.kev_catalog = {
            'vulnerabilities': [
                {'cveID': 'CVE-2021-44228', 'vendorProject': 'Apache'}
            ]
        }

        result = scorer.check_kev('CVE-2099-99999')
        assert result is False

    def test_check_kev_case_insensitive(self):
        """Test KEV check is case insensitive"""
        scorer = RiskScorer()
        scorer.kev_catalog = {
            'vulnerabilities': [
                {'cveID': 'CVE-2021-44228', 'vendorProject': 'Apache'}
            ]
        }

        result1 = scorer.check_kev('CVE-2021-44228')
        result2 = scorer.check_kev('cve-2021-44228')

        assert result1 is True
        assert result2 is True

    def test_check_kev_no_catalog_loaded(self):
        """Test checking KEV without loaded catalog"""
        scorer = RiskScorer()

        result = scorer.check_kev('CVE-2021-44228')
        assert result is False


class TestCVSSScoring:
    """Test CVSS base score handling"""

    def test_calculate_risk_score_basic(self):
        """Test basic risk score calculation"""
        scorer = RiskScorer()

        vulnerability = {
            'cve_id': 'CVE-2025-12345',
            'cvss_score': 7.5,
            'asset_criticality': 0.8,
            'exploitability': 0.5
        }

        risk_score = scorer.calculate_risk_score(vulnerability)

        assert isinstance(risk_score, float)
        assert 0.0 <= risk_score <= 10.0

    def test_calculate_risk_score_critical_vuln(self):
        """Test risk score for critical vulnerability"""
        scorer = RiskScorer()

        vulnerability = {
            'cve_id': 'CVE-2021-44228',  # Log4Shell
            'cvss_score': 10.0,
            'asset_criticality': 1.0,
            'exploitability': 1.0,
            'kev_listed': True
        }

        risk_score = scorer.calculate_risk_score(vulnerability)

        # Should have very high risk score
        assert risk_score >= 8.0

    def test_calculate_risk_score_low_priority(self):
        """Test risk score for low priority vulnerability"""
        scorer = RiskScorer()

        vulnerability = {
            'cve_id': 'CVE-2025-00001',
            'cvss_score': 2.0,
            'asset_criticality': 0.1,
            'exploitability': 0.1,
            'kev_listed': False
        }

        risk_score = scorer.calculate_risk_score(vulnerability)

        # Should have low risk score
        assert risk_score < 5.0


class TestAssetCriticality:
    """Test asset criticality assessment"""

    def test_assess_asset_criticality_production(self):
        """Test criticality assessment for production assets"""
        scorer = RiskScorer()

        asset = {
            'type': 'server',
            'environment': 'production',
            'business_impact': 'critical'
        }

        criticality = scorer.assess_asset_criticality(asset)

        assert isinstance(criticality, float)
        assert criticality >= 0.7  # Production should be high criticality

    def test_assess_asset_criticality_dev(self):
        """Test criticality assessment for dev assets"""
        scorer = RiskScorer()

        asset = {
            'type': 'server',
            'environment': 'development',
            'business_impact': 'low'
        }

        criticality = scorer.assess_asset_criticality(asset)

        assert isinstance(criticality, float)
        assert criticality <= 0.5  # Dev should be lower criticality

    @pytest.mark.parametrize("environment,expected_range", [
        ("production", (0.7, 1.0)),
        ("staging", (0.5, 0.8)),
        ("development", (0.1, 0.5)),
        ("test", (0.1, 0.4))
    ])
    def test_criticality_by_environment(self, environment, expected_range):
        """Test criticality varies by environment"""
        scorer = RiskScorer()

        asset = {'environment': environment}
        criticality = scorer.assess_asset_criticality(asset)

        min_expected, max_expected = expected_range
        # Criticality should be in expected range
        assert isinstance(criticality, float)


class TestExploitabilityScoring:
    """Test exploitability assessment"""

    def test_get_exploitability_high(self):
        """Test high exploitability score"""
        scorer = RiskScorer()

        # Vulnerability with public exploit
        vuln = {
            'cve_id': 'CVE-2021-44228',
            'exploit_available': True,
            'exploit_in_wild': True,
            'exploit_maturity': 'functional'
        }

        exploitability = scorer.get_exploitability(vuln)

        assert isinstance(exploitability, float)
        assert exploitability >= 0.7

    def test_get_exploitability_low(self):
        """Test low exploitability score"""
        scorer = RiskScorer()

        # Vulnerability with no known exploit
        vuln = {
            'cve_id': 'CVE-2025-99999',
            'exploit_available': False,
            'exploit_in_wild': False,
            'exploit_maturity': 'unproven'
        }

        exploitability = scorer.get_exploitability(vuln)

        assert isinstance(exploitability, float)
        assert exploitability <= 0.3

    def test_get_epss_score(self):
        """Test EPSS (Exploit Prediction Scoring System) retrieval"""
        scorer = RiskScorer()
        scorer.epss_data = {
            'CVE-2021-44228': 0.95,  # Very high EPSS
            'CVE-2025-00001': 0.01   # Very low EPSS
        }

        high_epss = scorer.get_epss_score('CVE-2021-44228')
        low_epss = scorer.get_epss_score('CVE-2025-00001')

        assert high_epss == 0.95
        assert low_epss == 0.01


class TestRiskFactorWeighting:
    """Test risk factor weighting"""

    def test_default_weights(self):
        """Test default risk factor weights"""
        scorer = RiskScorer()

        weights = scorer.get_risk_weights()

        assert isinstance(weights, dict)
        assert 'cvss' in weights
        assert 'exploitability' in weights
        assert 'asset_criticality' in weights

        # Weights should sum to 1.0
        total = sum(weights.values())
        assert 0.9 <= total <= 1.1  # Allow small floating point variance

    def test_custom_weights(self):
        """Test custom risk factor weights"""
        scorer = RiskScorer()

        custom_weights = {
            'cvss': 0.3,
            'exploitability': 0.4,
            'asset_criticality': 0.2,
            'threat_intel': 0.1
        }

        scorer.set_risk_weights(custom_weights)

        assert scorer.get_risk_weights() == custom_weights


class TestVulnerabilityPrioritization:
    """Test vulnerability prioritization"""

    def test_prioritize_vulnerabilities_basic(self):
        """Test basic vulnerability prioritization"""
        scorer = RiskScorer()

        vulnerabilities = [
            {'cve_id': 'CVE-1', 'cvss_score': 9.0, 'kev_listed': True},
            {'cve_id': 'CVE-2', 'cvss_score': 5.0, 'kev_listed': False},
            {'cve_id': 'CVE-3', 'cvss_score': 7.5, 'kev_listed': True}
        ]

        prioritized = scorer.prioritize_vulnerabilities(vulnerabilities)

        assert isinstance(prioritized, list)
        assert len(prioritized) == 3

        # Should be sorted by risk score (highest first)
        for i in range(len(prioritized) - 1):
            assert prioritized[i]['risk_score'] >= prioritized[i + 1]['risk_score']

    def test_prioritize_by_kev_status(self):
        """Test prioritization gives weight to KEV status"""
        scorer = RiskScorer()
        scorer.kev_catalog = {'vulnerabilities': [{'cveID': 'CVE-2021-44228'}]}

        vulnerabilities = [
            {'cve_id': 'CVE-2021-44228', 'cvss_score': 10.0},  # KEV-listed
            {'cve_id': 'CVE-2025-99999', 'cvss_score': 10.0}   # Not KEV-listed
        ]

        # Add KEV status
        for vuln in vulnerabilities:
            vuln['kev_listed'] = scorer.check_kev(vuln['cve_id'])

        # KEV-listed vuln should have higher priority
        kev_vuln = [v for v in vulnerabilities if v['kev_listed']][0]
        assert kev_vuln['kev_listed'] is True


class TestRiskScoreReporting:
    """Test risk score reporting"""

    def test_generate_risk_report(self, tmp_path):
        """Test generating risk score report"""
        scorer = RiskScorer()

        vulnerabilities = [
            {
                'cve_id': 'CVE-2025-001',
                'cvss_score': 9.0,
                'risk_score': 8.5,
                'priority': 'CRITICAL'
            },
            {
                'cve_id': 'CVE-2025-002',
                'cvss_score': 5.0,
                'risk_score': 4.2,
                'priority': 'MEDIUM'
            }
        ]

        report_file = tmp_path / "risk_report.json"
        report_data = {
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': vulnerabilities,
            'summary': {
                'total': len(vulnerabilities),
                'critical': sum(1 for v in vulnerabilities if v['priority'] == 'CRITICAL')
            }
        }

        with open(report_file, 'w') as f:
            json.dump(report_data, f, indent=2)

        assert report_file.exists()


# [+] Integration tests
@pytest.mark.integration
class TestRiskScorerIntegration:
    """Integration tests for risk scoring"""

    @patch('vulnerability_mgmt.prioritization.risk_scorer.requests.get')
    def test_complete_risk_scoring_workflow(self, mock_get, tmp_path):
        """Test complete risk scoring workflow"""
        # Mock KEV catalog
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {'cveID': 'CVE-2021-44228', 'vendorProject': 'Apache'}
            ]
        }
        mock_get.return_value = mock_response

        # Initialize scorer
        scorer = RiskScorer()
        scorer.load_kev_catalog()

        # Score vulnerabilities
        vulnerabilities = [
            {
                'cve_id': 'CVE-2021-44228',
                'cvss_score': 10.0,
                'asset_criticality': 1.0
            },
            {
                'cve_id': 'CVE-2025-99999',
                'cvss_score': 5.0,
                'asset_criticality': 0.5
            }
        ]

        # Calculate risk scores
        for vuln in vulnerabilities:
            vuln['kev_listed'] = scorer.check_kev(vuln['cve_id'])
            vuln['risk_score'] = scorer.calculate_risk_score(vuln)

        # Prioritize
        prioritized = sorted(vulnerabilities, key=lambda x: x['risk_score'], reverse=True)

        # Generate report
        report_file = tmp_path / "risk_report.json"
        with open(report_file, 'w') as f:
            json.dump(prioritized, f, indent=2)

        assert report_file.exists()
        # Log4Shell should be highest priority
        assert prioritized[0]['cve_id'] == 'CVE-2021-44228'


# [+] Parametrized tests
@pytest.mark.parametrize("cvss_score,expected_range", [
    (10.0, (9.0, 10.0)),
    (7.5, (6.0, 8.5)),
    (5.0, (3.0, 6.0)),
    (2.0, (1.0, 3.0))
])
def test_risk_score_by_cvss(cvss_score, expected_range):
    """Test risk scores correlate with CVSS"""
    scorer = RiskScorer()

    vuln = {
        'cvss_score': cvss_score,
        'asset_criticality': 0.5,
        'exploitability': 0.5
    }

    risk_score = scorer.calculate_risk_score(vuln)
    min_expected, max_expected = expected_range

    # Risk score should roughly correlate with CVSS
    assert isinstance(risk_score, float)


@pytest.mark.parametrize("kev_listed", [True, False])
def test_kev_impact_on_priority(kev_listed):
    """Test KEV listing impacts priority"""
    scorer = RiskScorer()

    vuln = {
        'cvss_score': 7.5,
        'kev_listed': kev_listed
    }

    # KEV-listed vulns should get priority boost
    if kev_listed:
        assert vuln['kev_listed'] is True


# [+] Performance tests
@pytest.mark.slow
def test_large_scale_vulnerability_scoring():
    """Test scoring large number of vulnerabilities"""
    import time

    scorer = RiskScorer()

    # Generate 1000 vulnerabilities
    vulnerabilities = [
        {
            'cve_id': f'CVE-2025-{i:05d}',
            'cvss_score': (i % 10) + 1,
            'asset_criticality': (i % 10) / 10.0
        }
        for i in range(1000)
    ]

    start = time.time()
    for vuln in vulnerabilities:
        vuln['risk_score'] = scorer.calculate_risk_score(vuln)
    duration = time.time() - start

    # Should score 1000 vulns in < 5 seconds
    assert duration < 5.0
    assert all('risk_score' in v for v in vulnerabilities)
