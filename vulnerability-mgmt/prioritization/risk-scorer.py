#!/usr/bin/env python3
"""
Risk-Based Vulnerability Scoring Engine
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Multi-factor risk scoring for vulnerabilities combining:
    - CVSS base score
    - Exploitability (EPSS, KEV catalog)
    - Asset criticality
    - Environmental factors
    - Threat intelligence

Requirements:
    - requests (pip install requests)
    - Python 3.8+

Usage:
    python risk-scorer.py --vulnerabilities vulns.json --output scored_vulns.json
    python risk-scorer.py --vulnerabilities scan_results.json --asset-critical --output prioritized.json
    python risk-scorer.py --vulnerabilities vulns.json --kev-check --output results.json
"""

import argparse
import json
import logging
import os
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    logging.warning("requests not available. Install: pip install requests")

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class RiskScorer:
    """Risk-based vulnerability scoring engine"""

    def __init__(self):
        self.kev_catalog = None
        self.epss_data = {}

    def load_kev_catalog(self) -> bool:
        """
        Load CISA KEV (Known Exploited Vulnerabilities) catalog

        Returns:
            bool: True if loaded successfully
        """
        logger.info("[+] Loading CISA KEV catalog...")

        if not REQUESTS_AVAILABLE:
            logger.warning("[!] requests library not available")
            return False

        try:
            response = requests.get(
                'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
                timeout=30
            )

            if response.status_code == 200:
                self.kev_catalog = response.json()
                vuln_count = len(self.kev_catalog.get('vulnerabilities', []))
                logger.info(f"[OK] Loaded {vuln_count} known exploited vulnerabilities")
                return True
            else:
                logger.error(f"[X] Failed to load KEV catalog: HTTP {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"[X] Error loading KEV catalog: {e}")
            return False

    def check_kev(self, cve_id: str) -> bool:
        """
        Check if CVE is in KEV catalog

        Args:
            cve_id: CVE ID (e.g., CVE-2021-44228)

        Returns:
            bool: True if in KEV catalog
        """
        if not self.kev_catalog:
            return False

        for vuln in self.kev_catalog.get('vulnerabilities', []):
            if vuln.get('cveID', '').upper() == cve_id.upper():
                return True

        return False

    def get_epss_score(self, cve_id: str) -> float:
        """
        Get EPSS (Exploit Prediction Scoring System) score

        Args:
            cve_id: CVE ID

        Returns:
            float: EPSS score (0.0-1.0) or 0.0 if unavailable
        """
        # For now, return cached or default
        # Full implementation would query FIRST EPSS API
        return self.epss_data.get(cve_id, 0.0)

    def calculate_risk_score(self, vuln: Dict, asset_criticality: str = 'medium',
                            environment: str = 'production') -> Dict:
        """
        Calculate multi-factor risk score

        Args:
            vuln: Vulnerability data
            asset_criticality: Asset criticality (low, medium, high, critical)
            environment: Environment type (production, staging, development)

        Returns:
            dict: Risk scoring details
        """
        scores = {
            'cvss_base': 0.0,
            'exploitability': 0.0,
            'asset_criticality': 0.0,
            'environmental': 0.0,
            'threat_intelligence': 0.0
        }

        # 1. CVSS Base Score (40% weight)
        cvss_score = self._extract_cvss(vuln)
        scores['cvss_base'] = cvss_score * 0.4

        # 2. Exploitability (30% weight)
        exploitability = self._calculate_exploitability(vuln)
        scores['exploitability'] = exploitability * 0.3

        # 3. Asset Criticality (20% weight)
        criticality_map = {'low': 0.25, 'medium': 0.5, 'high': 0.75, 'critical': 1.0}
        scores['asset_criticality'] = criticality_map.get(asset_criticality, 0.5) * 0.2 * 10

        # 4. Environmental Factors (5% weight)
        env_map = {'development': 0.3, 'staging': 0.6, 'production': 1.0}
        scores['environmental'] = env_map.get(environment, 1.0) * 0.05 * 10

        # 5. Threat Intelligence (5% weight)
        threat_intel = self._assess_threat_intelligence(vuln)
        scores['threat_intelligence'] = threat_intel * 0.05 * 10

        # Calculate total risk score (0-10)
        total_score = sum(scores.values())

        # Determine priority
        if total_score >= 9.0:
            priority = 'critical'
        elif total_score >= 7.0:
            priority = 'high'
        elif total_score >= 4.0:
            priority = 'medium'
        else:
            priority = 'low'

        return {
            'risk_score': round(total_score, 2),
            'priority': priority,
            'component_scores': scores,
            'factors': {
                'cvss_base': cvss_score,
                'in_kev': self.check_kev(self._extract_cve(vuln)),
                'has_exploit': self._has_exploit(vuln),
                'asset_criticality': asset_criticality,
                'environment': environment
            }
        }

    def _extract_cvss(self, vuln: Dict) -> float:
        """Extract CVSS base score from vulnerability"""
        # Try different field names
        if 'cvss' in vuln:
            if isinstance(vuln['cvss'], dict):
                return float(vuln['cvss'].get('baseScore', 0.0))
            return float(vuln['cvss'])

        if 'cvss_base' in vuln:
            return float(vuln['cvss_base'])

        if 'severity' in vuln:
            severity = vuln['severity']
            if isinstance(severity, (int, float)):
                return float(severity)

        # Map severity strings to CVSS scores
        severity_map = {
            'CRITICAL': 9.5,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5
        }

        severity_str = str(vuln.get('severity', vuln.get('Severity', ''))).upper()
        return severity_map.get(severity_str, 0.0)

    def _extract_cve(self, vuln: Dict) -> str:
        """Extract CVE ID from vulnerability"""
        cve_fields = ['cve', 'cveID', 'VulnerabilityID', 'id', 'vulnerability_id']

        for field in cve_fields:
            if field in vuln and vuln[field]:
                cve_value = str(vuln[field])
                if cve_value.upper().startswith('CVE-'):
                    return cve_value.upper()

        return ''

    def _calculate_exploitability(self, vuln: Dict) -> float:
        """Calculate exploitability score (0-10)"""
        score = 0.0

        # Check KEV catalog (high weight)
        cve_id = self._extract_cve(vuln)
        if cve_id and self.check_kev(cve_id):
            score = 10.0
            return score

        # Check for public exploits
        if self._has_exploit(vuln):
            score = 8.0
            return score

        # Check EPSS score
        epss = self.get_epss_score(cve_id)
        if epss > 0:
            score = epss * 10
            return score

        # Default based on CVSS
        cvss = self._extract_cvss(vuln)
        if cvss >= 9.0:
            score = 6.0
        elif cvss >= 7.0:
            score = 4.0
        elif cvss >= 4.0:
            score = 2.0

        return score

    def _has_exploit(self, vuln: Dict) -> bool:
        """Check if exploit is available"""
        # Check exploit-related fields
        if 'exploit' in str(vuln).lower():
            return True

        # Check references for exploit keywords
        references = vuln.get('references', vuln.get('References', []))
        if references:
            refs_str = str(references).lower()
            exploit_keywords = ['exploit', 'exploit-db', 'metasploit', 'poc', 'proof of concept']
            return any(keyword in refs_str for keyword in exploit_keywords)

        return False

    def _assess_threat_intelligence(self, vuln: Dict) -> float:
        """Assess threat intelligence factors (0-10)"""
        score = 0.0

        # Check age of vulnerability
        published_date = vuln.get('publishedDate', vuln.get('published', ''))
        if published_date:
            try:
                # Newer vulnerabilities get higher score
                pub_date = datetime.fromisoformat(published_date.replace('Z', '+00:00'))
                age_days = (datetime.now(pub_date.tzinfo) - pub_date).days

                if age_days < 30:
                    score += 3.0
                elif age_days < 90:
                    score += 2.0
                elif age_days < 365:
                    score += 1.0
            except:
                pass

        # Check for ransomware/worm keywords
        description = str(vuln.get('description', vuln.get('Description', ''))).lower()
        threat_keywords = {
            'ransomware': 3.0,
            'worm': 2.5,
            'botnet': 2.5,
            'remote code execution': 2.0,
            'zero-day': 3.0
        }

        for keyword, points in threat_keywords.items():
            if keyword in description:
                score += points
                break

        return min(score, 10.0)

    def score_vulnerabilities(self, vulnerabilities: List[Dict],
                            asset_criticality: str = 'medium',
                            environment: str = 'production') -> List[Dict]:
        """
        Score all vulnerabilities

        Args:
            vulnerabilities: List of vulnerabilities
            asset_criticality: Asset criticality level
            environment: Environment type

        Returns:
            list: Vulnerabilities with risk scores
        """
        logger.info(f"[+] Scoring {len(vulnerabilities)} vulnerabilities...")

        scored_vulns = []

        for vuln in vulnerabilities:
            risk_assessment = self.calculate_risk_score(vuln, asset_criticality, environment)

            scored_vuln = vuln.copy()
            scored_vuln['risk_assessment'] = risk_assessment

            scored_vulns.append(scored_vuln)

        # Sort by risk score (highest first)
        scored_vulns.sort(key=lambda x: x['risk_assessment']['risk_score'], reverse=True)

        logger.info("[OK] Scoring complete")
        return scored_vulns

    def generate_report(self, scored_vulns: List[Dict], output_file: Path) -> None:
        """
        Generate prioritization report

        Args:
            scored_vulns: Scored vulnerabilities
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Vulnerability Risk Assessment Report\n")
                f.write("="*70 + "\n\n")

                f.write(f"Generated: {datetime.now().isoformat()}\n")
                f.write(f"Total Vulnerabilities: {len(scored_vulns)}\n\n")

                # Summary by priority
                priority_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
                for vuln in scored_vulns:
                    priority = vuln['risk_assessment']['priority']
                    priority_counts[priority] += 1

                f.write("Priority Distribution:\n")
                for priority in ['critical', 'high', 'medium', 'low']:
                    count = priority_counts[priority]
                    f.write(f"  {priority.upper()}: {count}\n")

                f.write("\n")
                f.write("="*70 + "\n")
                f.write("Top 50 Priority Vulnerabilities\n")
                f.write("="*70 + "\n\n")

                for i, vuln in enumerate(scored_vulns[:50], 1):
                    risk_assess = vuln['risk_assessment']

                    f.write(f"\n{i}. [{risk_assess['priority'].upper()}] Risk Score: {risk_assess['risk_score']}/10\n")

                    # CVE/ID
                    cve_id = self._extract_cve(vuln)
                    vuln_name = vuln.get('name', vuln.get('VulnerabilityID', vuln.get('id', 'Unknown')))
                    f.write(f"   {cve_id if cve_id else vuln_name}\n")

                    # Key factors
                    factors = risk_assess['factors']
                    f.write(f"   CVSS: {factors['cvss_base']:.1f}")

                    if factors['in_kev']:
                        f.write(" | [!] IN KEV CATALOG")
                    if factors['has_exploit']:
                        f.write(" | Exploit Available")

                    f.write(f" | Asset: {factors['asset_criticality']}")
                    f.write(f" | Env: {factors['environment']}\n")

                    # Description (truncated)
                    desc = vuln.get('description', vuln.get('Description', vuln.get('Title', '')))
                    if desc:
                        desc_short = desc[:150] + "..." if len(desc) > 150 else desc
                        f.write(f"   {desc_short}\n")

                    f.write("-"*70 + "\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")


def main():
    parser = argparse.ArgumentParser(description='Risk-based vulnerability scoring')
    parser.add_argument('--vulnerabilities', type=Path, required=True,
                        help='Vulnerability JSON file')
    parser.add_argument('--output', type=Path, required=True,
                        help='Output JSON file')
    parser.add_argument('--asset-critical', action='store_true',
                        help='Mark asset as critical (default: medium)')
    parser.add_argument('--asset-criticality', choices=['low', 'medium', 'high', 'critical'],
                        default='medium', help='Asset criticality level')
    parser.add_argument('--environment', choices=['development', 'staging', 'production'],
                        default='production', help='Environment type')
    parser.add_argument('--kev-check', action='store_true',
                        help='Check against CISA KEV catalog')
    parser.add_argument('--report', action='store_true',
                        help='Generate text report')

    args = parser.parse_args()

    if not args.vulnerabilities.exists():
        logger.error(f"[X] Vulnerability file not found: {args.vulnerabilities}")
        return 1

    # Override criticality if asset-critical flag set
    if args.asset_critical:
        args.asset_criticality = 'critical'

    # Initialize scorer
    scorer = RiskScorer()

    # Load KEV catalog if requested
    if args.kev_check:
        scorer.load_kev_catalog()

    # Load vulnerabilities
    logger.info(f"[+] Loading vulnerabilities from: {args.vulnerabilities}")

    try:
        with open(args.vulnerabilities, 'r') as f:
            data = json.load(f)

        # Extract vulnerabilities from different formats
        if isinstance(data, list):
            vulnerabilities = data
        elif 'vulnerabilities' in data:
            vulnerabilities = data['vulnerabilities']
        elif 'results' in data:
            # Trivy format
            vulnerabilities = []
            for result in data['results']:
                vulnerabilities.extend(result.get('Vulnerabilities', []))
        else:
            logger.error("[X] Unsupported vulnerability file format")
            return 1

        logger.info(f"[OK] Loaded {len(vulnerabilities)} vulnerabilities")

    except Exception as e:
        logger.error(f"[X] Error loading vulnerabilities: {e}")
        return 1

    # Score vulnerabilities
    scored_vulns = scorer.score_vulnerabilities(
        vulnerabilities,
        args.asset_criticality,
        args.environment
    )

    # Save results
    output_data = {
        'metadata': {
            'timestamp': datetime.now().isoformat(),
            'asset_criticality': args.asset_criticality,
            'environment': args.environment,
            'kev_checked': args.kev_check
        },
        'summary': {
            'total': len(scored_vulns),
            'critical': len([v for v in scored_vulns if v['risk_assessment']['priority'] == 'critical']),
            'high': len([v for v in scored_vulns if v['risk_assessment']['priority'] == 'high']),
            'medium': len([v for v in scored_vulns if v['risk_assessment']['priority'] == 'medium']),
            'low': len([v for v in scored_vulns if v['risk_assessment']['priority'] == 'low'])
        },
        'vulnerabilities': scored_vulns
    }

    with open(args.output, 'w') as f:
        json.dump(output_data, f, indent=2)

    logger.info(f"[OK] Scored vulnerabilities saved to: {args.output}")

    # Generate report if requested
    if args.report:
        report_file = args.output.parent / f"{args.output.stem}_report.txt"
        scorer.generate_report(scored_vulns, report_file)

    # Print summary
    summary = output_data['summary']
    logger.info(f"\n[+] Risk Assessment Summary:")
    logger.info(f"    Total: {summary['total']}")
    logger.info(f"    Critical: {summary['critical']}")
    logger.info(f"    High: {summary['high']}")
    logger.info(f"    Medium: {summary['medium']}")
    logger.info(f"    Low: {summary['low']}")

    return 0


if __name__ == '__main__':
    exit(main())
