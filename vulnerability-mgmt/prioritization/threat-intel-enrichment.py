#!/usr/bin/env python3
"""
Threat Intelligence Enrichment for Vulnerabilities
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Enriches vulnerability data with threat intelligence from:
    - CISA KEV catalog
    - NVD (National Vulnerability Database)
    - Exploit-DB searches
    - Public exploit availability

Requirements:
    - requests (pip install requests)
    - Python 3.8+

Usage:
    python threat-intel-enrichment.py --vulnerabilities vulns.json --output enriched.json
    python threat-intel-enrichment.py --cve CVE-2021-44228 --output log4j_intel.json
"""

import argparse
import json
import logging
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class ThreatIntelEnricher:
    """Enrich vulnerabilities with threat intelligence"""

    def __init__(self):
        self.kev_catalog = None
        self.nvd_cache = {}
        self.session = requests.Session() if REQUESTS_AVAILABLE else None

    def load_kev(self) -> bool:
        """Load CISA KEV catalog"""
        logger.info("[+] Loading CISA KEV catalog...")

        try:
            response = self.session.get(
                'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
                timeout=30
            )
            self.kev_catalog = response.json()
            logger.info(f"[OK] Loaded {len(self.kev_catalog.get('vulnerabilities', []))} KEV entries")
            return True
        except Exception as e:
            logger.error(f"[X] KEV load failed: {e}")
            return False

    def get_kev_details(self, cve_id: str) -> Optional[Dict]:
        """Get KEV catalog details for CVE"""
        if not self.kev_catalog:
            return None

        for vuln in self.kev_catalog.get('vulnerabilities', []):
            if vuln.get('cveID', '').upper() == cve_id.upper():
                return {
                    'in_kev': True,
                    'date_added': vuln.get('dateAdded'),
                    'due_date': vuln.get('dueDate'),
                    'known_ransomware': vuln.get('knownRansomwareCampaignUse', 'Unknown'),
                    'notes': vuln.get('notes', '')
                }
        return {'in_kev': False}

    def query_nvd(self, cve_id: str) -> Optional[Dict]:
        """Query NVD for CVE details"""
        if cve_id in self.nvd_cache:
            return self.nvd_cache[cve_id]

        logger.info(f"[+] Querying NVD for {cve_id}...")

        try:
            response = self.session.get(
                f'https://services.nvd.nist.gov/rest/json/cves/2.0',
                params={'cveId': cve_id},
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                if data.get('vulnerabilities'):
                    cve_item = data['vulnerabilities'][0]['cve']
                    nvd_data = {
                        'description': cve_item.get('descriptions', [{}])[0].get('value', ''),
                        'published': cve_item.get('published'),
                        'references': [ref.get('url') for ref in cve_item.get('references', [])[:5]],
                        'cvss_v3': None,
                        'cvss_v2': None
                    }

                    # Extract CVSS scores
                    metrics = cve_item.get('metrics', {})
                    if 'cvssMetricV31' in metrics:
                        cvss_v3 = metrics['cvssMetricV31'][0]['cvssData']
                        nvd_data['cvss_v3'] = cvss_v3.get('baseScore')
                    if 'cvssMetricV2' in metrics:
                        cvss_v2 = metrics['cvssMetricV2'][0]['cvssData']
                        nvd_data['cvss_v2'] = cvss_v2.get('baseScore')

                    self.nvd_cache[cve_id] = nvd_data
                    time.sleep(0.6)  # Rate limit: 5 requests per 30 seconds
                    return nvd_data

            return None

        except Exception as e:
            logger.warning(f"[!] NVD query failed for {cve_id}: {e}")
            return None

    def check_exploits(self, cve_id: str, references: List[str] = None) -> Dict:
        """Check for public exploits"""
        exploit_sources = {
            'exploit-db': False,
            'metasploit': False,
            'github_poc': False,
            'references_with_exploit': []
        }

        if references:
            refs_str = ' '.join(references).lower()
            exploit_sources['exploit-db'] = 'exploit-db' in refs_str
            exploit_sources['metasploit'] = 'metasploit' in refs_str
            exploit_sources['github_poc'] = 'github.com' in refs_str and ('poc' in refs_str or 'exploit' in refs_str)

            exploit_sources['references_with_exploit'] = [
                ref for ref in references
                if any(keyword in ref.lower() for keyword in ['exploit', 'poc', 'metasploit'])
            ]

        return exploit_sources

    def enrich_vulnerability(self, vuln: Dict) -> Dict:
        """Enrich single vulnerability with threat intel"""
        # Extract CVE ID
        cve_id = None
        for field in ['cve', 'cveID', 'VulnerabilityID', 'id']:
            if field in vuln:
                cve_value = str(vuln[field])
                if cve_value.upper().startswith('CVE-'):
                    cve_id = cve_value.upper()
                    break

        if not cve_id:
            return vuln

        enriched = vuln.copy()
        enriched['threat_intelligence'] = {}

        # KEV enrichment
        kev_details = self.get_kev_details(cve_id)
        if kev_details:
            enriched['threat_intelligence']['kev'] = kev_details

        # NVD enrichment
        nvd_data = self.query_nvd(cve_id)
        if nvd_data:
            enriched['threat_intelligence']['nvd'] = nvd_data

        # Exploit enrichment
        references = vuln.get('references', vuln.get('References', []))
        if isinstance(references, list) and references:
            exploit_info = self.check_exploits(cve_id, references)
            enriched['threat_intelligence']['exploits'] = exploit_info

        return enriched

    def enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enrich all vulnerabilities"""
        logger.info(f"[+] Enriching {len(vulnerabilities)} vulnerabilities...")

        enriched = []
        for i, vuln in enumerate(vulnerabilities, 1):
            if i % 10 == 0:
                logger.info(f"    Progress: {i}/{len(vulnerabilities)}")

            enriched_vuln = self.enrich_vulnerability(vuln)
            enriched.append(enriched_vuln)

        logger.info("[OK] Enrichment complete")
        return enriched


def main():
    parser = argparse.ArgumentParser(description='Threat intelligence enrichment')
    parser.add_argument('--vulnerabilities', type=Path, help='Vulnerability JSON file')
    parser.add_argument('--cve', help='Single CVE to enrich')
    parser.add_argument('--output', type=Path, required=True, help='Output JSON file')

    args = parser.parse_args()

    if not REQUESTS_AVAILABLE:
        logger.error("[X] requests library required. Install: pip install requests")
        return 1

    if not args.vulnerabilities and not args.cve:
        logger.error("[X] Either --vulnerabilities or --cve required")
        return 1

    enricher = ThreatIntelEnricher()
    enricher.load_kev()

    if args.cve:
        # Enrich single CVE
        vuln = {'cve': args.cve}
        enriched = enricher.enrich_vulnerability(vuln)

        with open(args.output, 'w') as f:
            json.dump(enriched, f, indent=2)

        logger.info(f"[OK] Saved to: {args.output}")

    else:
        # Enrich vulnerability list
        with open(args.vulnerabilities, 'r') as f:
            data = json.load(f)

        if isinstance(data, list):
            vulns = data
        elif 'vulnerabilities' in data:
            vulns = data['vulnerabilities']
        else:
            logger.error("[X] Unsupported format")
            return 1

        enriched = enricher.enrich_vulnerabilities(vulns)

        with open(args.output, 'w') as f:
            json.dump({
                'metadata': {'timestamp': datetime.now().isoformat()},
                'vulnerabilities': enriched
            }, f, indent=2)

        logger.info(f"[OK] Saved to: {args.output}")

    return 0


if __name__ == '__main__':
    exit(main())
