#!/usr/bin/env python3
"""
Nmap NSE Vulnerability Scanner
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Automated Nmap vulnerability scanning using NSE (Nmap Scripting Engine).
    Runs vulnerability detection scripts and formats results for analysis.

Requirements:
    - nmap installed on system
    - python-nmap (pip install python-nmap)
    - Python 3.8+

Usage:
    python nmap-vuln-scan.py --target 192.168.1.100 --output results/
    python nmap-vuln-scan.py --target 10.0.0.0/24 --quick --output scan/
    python nmap-vuln-scan.py --target-file hosts.txt --output scans/
"""

import argparse
import json
import logging
import subprocess
import sys
import xml.etree.ElementTree as ET
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False
    logging.warning("python-nmap not available. Install: pip install python-nmap")

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class NmapVulnScanner:
    """Nmap NSE vulnerability scanner"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.nm = nmap.PortScanner() if NMAP_AVAILABLE else None

    def check_nmap(self) -> bool:
        """
        Check if nmap is installed

        Returns:
            bool: True if nmap is available
        """
        try:
            result = subprocess.run(['nmap', '--version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def scan_vulnerabilities(self, target: str, quick: bool = False, ports: str = None) -> Dict:
        """
        Scan target for vulnerabilities using NSE scripts

        Args:
            target: Target host or network
            quick: Quick scan (fewer scripts)
            ports: Port specification (default: common ports)

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning target: {target}")

        if not self.check_nmap():
            logger.error("[X] nmap not found. Install: apt install nmap")
            return {}

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_base = self.output_dir / f"nmap_vuln_{target.replace('/', '_')}_{timestamp}"

        # Build nmap command
        if quick:
            # Quick scan - common vulnerabilities
            scripts = 'vuln,exploit'
            scan_ports = ports or '21-23,25,80,110,139,143,443,445,3306,3389,8080'
        else:
            # Full scan - comprehensive vulnerability checks
            scripts = 'vuln,exploit,discovery,auth,brute'
            scan_ports = ports or '1-1000'

        nmap_args = [
            'nmap',
            '-sV',  # Service version detection
            '--script', scripts,
            '-p', scan_ports,
            '-oX', f"{output_base}.xml",
            '-oN', f"{output_base}.txt",
            target
        ]

        logger.info(f"[i] Running: {' '.join(nmap_args)}")

        try:
            result = subprocess.run(
                nmap_args,
                capture_output=True,
                text=True,
                timeout=3600  # 1 hour timeout
            )

            if result.returncode == 0:
                logger.info("[OK] Scan completed successfully")

                # Parse XML output
                scan_results = self.parse_xml_results(f"{output_base}.xml")

                # Save JSON report
                json_output = f"{output_base}.json"
                with open(json_output, 'w') as f:
                    json.dump(scan_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {json_output}")
                return scan_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except subprocess.TimeoutExpired:
            logger.error("[X] Scan timed out (1 hour)")
            return {}
        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def parse_xml_results(self, xml_file: Path) -> Dict:
        """
        Parse nmap XML output

        Args:
            xml_file: Path to XML file

        Returns:
            dict: Parsed results
        """
        logger.info("[+] Parsing scan results...")

        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()

            results = {
                'timestamp': datetime.now().isoformat(),
                'scanner': 'nmap',
                'scan_info': {},
                'hosts': []
            }

            # Parse scan info
            scaninfo = root.find('scaninfo')
            if scaninfo is not None:
                results['scan_info'] = {
                    'type': scaninfo.get('type'),
                    'protocol': scaninfo.get('protocol'),
                    'services': scaninfo.get('services')
                }

            # Parse hosts
            for host in root.findall('host'):
                host_data = self._parse_host(host)
                if host_data:
                    results['hosts'].append(host_data)

            # Generate summary
            total_vulns = sum(len(h.get('vulnerabilities', [])) for h in results['hosts'])
            results['summary'] = {
                'total_hosts': len(results['hosts']),
                'total_vulnerabilities': total_vulns,
                'hosts_with_vulns': len([h for h in results['hosts'] if h.get('vulnerabilities')])
            }

            logger.info(f"[OK] Found {total_vulns} vulnerabilities across {len(results['hosts'])} hosts")
            return results

        except Exception as e:
            logger.error(f"[X] Error parsing XML: {e}")
            return {}

    def _parse_host(self, host_elem) -> Dict:
        """Parse host element from XML"""
        host_data = {
            'status': host_elem.find('status').get('state') if host_elem.find('status') is not None else 'unknown',
            'addresses': [],
            'hostnames': [],
            'ports': [],
            'vulnerabilities': []
        }

        # Parse addresses
        for addr in host_elem.findall('address'):
            host_data['addresses'].append({
                'addr': addr.get('addr'),
                'type': addr.get('addrtype')
            })

        # Parse hostnames
        hostnames_elem = host_elem.find('hostnames')
        if hostnames_elem is not None:
            for hostname in hostnames_elem.findall('hostname'):
                host_data['hostnames'].append({
                    'name': hostname.get('name'),
                    'type': hostname.get('type')
                })

        # Parse ports
        ports_elem = host_elem.find('ports')
        if ports_elem is not None:
            for port in ports_elem.findall('port'):
                port_data = self._parse_port(port)
                if port_data:
                    host_data['ports'].append(port_data)

                    # Extract vulnerabilities from scripts
                    script_vulns = self._extract_vulnerabilities(port)
                    host_data['vulnerabilities'].extend(script_vulns)

        return host_data

    def _parse_port(self, port_elem) -> Dict:
        """Parse port element"""
        port_data = {
            'port': port_elem.get('portid'),
            'protocol': port_elem.get('protocol'),
            'state': port_elem.find('state').get('state') if port_elem.find('state') is not None else 'unknown'
        }

        # Parse service info
        service = port_elem.find('service')
        if service is not None:
            port_data['service'] = {
                'name': service.get('name'),
                'product': service.get('product'),
                'version': service.get('version'),
                'extrainfo': service.get('extrainfo')
            }

        return port_data

    def _extract_vulnerabilities(self, port_elem) -> List[Dict]:
        """Extract vulnerabilities from NSE scripts"""
        vulnerabilities = []

        for script in port_elem.findall('script'):
            script_id = script.get('id')
            script_output = script.get('output', '')

            # Check if this is a vulnerability-related script
            if any(keyword in script_id for keyword in ['vuln', 'exploit', 'cve', 'dos']):
                # Try to extract CVE IDs
                cves = self._extract_cves(script_output)

                vuln = {
                    'script': script_id,
                    'port': port_elem.get('portid'),
                    'description': script_output.strip(),
                    'cves': cves,
                    'severity': self._estimate_severity(script_id, script_output)
                }

                vulnerabilities.append(vuln)

        return vulnerabilities

    def _extract_cves(self, text: str) -> List[str]:
        """Extract CVE IDs from text"""
        import re
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        return list(set(re.findall(cve_pattern, text, re.IGNORECASE)))

    def _estimate_severity(self, script_id: str, output: str) -> str:
        """Estimate vulnerability severity based on keywords"""
        output_lower = output.lower()
        script_lower = script_id.lower()

        # High severity indicators
        if any(keyword in output_lower or keyword in script_lower
               for keyword in ['exploit', 'remote code execution', 'rce', 'critical', 'dangerous']):
            return 'high'

        # Medium severity indicators
        if any(keyword in output_lower or keyword in script_lower
               for keyword in ['vulnerable', 'injection', 'disclosure', 'bypass']):
            return 'medium'

        # Low severity
        return 'low'

    def generate_report(self, results: Dict, output_file: Path) -> None:
        """
        Generate human-readable report

        Args:
            results: Scan results
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Nmap Vulnerability Scan Report\n")
                f.write("="*70 + "\n\n")

                f.write(f"Timestamp: {results.get('timestamp', 'N/A')}\n")
                f.write(f"Scanner: {results.get('scanner', 'nmap')}\n\n")

                summary = results.get('summary', {})
                f.write("Summary:\n")
                f.write(f"  Total Hosts: {summary.get('total_hosts', 0)}\n")
                f.write(f"  Hosts with Vulnerabilities: {summary.get('hosts_with_vulns', 0)}\n")
                f.write(f"  Total Vulnerabilities: {summary.get('total_vulnerabilities', 0)}\n\n")

                # Host details
                f.write("="*70 + "\n")
                f.write("Host Details\n")
                f.write("="*70 + "\n\n")

                for host in results.get('hosts', []):
                    if not host.get('vulnerabilities'):
                        continue

                    # Host header
                    ip = host['addresses'][0]['addr'] if host.get('addresses') else 'Unknown'
                    f.write(f"\nHost: {ip}\n")
                    f.write("-"*70 + "\n")

                    # Vulnerabilities
                    for vuln in host['vulnerabilities']:
                        f.write(f"\n[{vuln['severity'].upper()}] Port {vuln['port']} - {vuln['script']}\n")
                        if vuln.get('cves'):
                            f.write(f"CVEs: {', '.join(vuln['cves'])}\n")
                        f.write(f"Description:\n{vuln['description']}\n")
                        f.write("-"*70 + "\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")


def main():
    parser = argparse.ArgumentParser(description='Nmap NSE vulnerability scanner')
    parser.add_argument('--target', help='Target host or network')
    parser.add_argument('--target-file', type=Path, help='File with target list')
    parser.add_argument('--output', type=Path, default=Path('nmap_scans'), help='Output directory')
    parser.add_argument('--quick', action='store_true', help='Quick scan (fewer scripts)')
    parser.add_argument('--ports', help='Port specification (e.g., 80,443,8080 or 1-1000)')

    args = parser.parse_args()

    if not NMAP_AVAILABLE:
        logger.warning("[!] python-nmap not available. Falling back to direct nmap execution.")

    if not args.target and not args.target_file:
        logger.error("[X] Target required. Use --target or --target-file")
        parser.print_help()
        return 1

    scanner = NmapVulnScanner(args.output)

    # Get targets
    targets = []
    if args.target:
        targets.append(args.target)
    if args.target_file:
        with open(args.target_file, 'r') as f:
            targets.extend([line.strip() for line in f if line.strip()])

    # Scan each target
    for target in targets:
        results = scanner.scan_vulnerabilities(target, args.quick, args.ports)

        if results:
            # Generate text report
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            report_file = args.output / f"nmap_report_{target.replace('/', '_')}_{timestamp}.txt"
            scanner.generate_report(results, report_file)

    return 0


if __name__ == '__main__':
    exit(main())
