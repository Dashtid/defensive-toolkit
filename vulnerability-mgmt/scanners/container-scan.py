#!/usr/bin/env python3
"""
Container and Image Vulnerability Scanner
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Scans Docker containers and images for vulnerabilities using Trivy.
    Supports scanning local images, registries, and running containers.

Requirements:
    - Trivy installed (https://aquasecurity.github.io/trivy/)
    - Python 3.8+

Usage:
    python container-scan.py --image nginx:latest --output results/
    python container-scan.py --image myapp:1.0 --severity HIGH,CRITICAL
    python container-scan.py --registry myregistry.azurecr.io/app:latest --output scans/
"""

import argparse
import json
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class ContainerScanner:
    """Container vulnerability scanner using Trivy"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def check_trivy(self) -> bool:
        """
        Check if Trivy is installed

        Returns:
            bool: True if Trivy is available
        """
        try:
            result = subprocess.run(['trivy', '--version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def scan_image(self, image: str, severity: List[str] = None, scan_type: str = 'all') -> Dict:
        """
        Scan container image for vulnerabilities

        Args:
            image: Image name (e.g., nginx:latest)
            severity: List of severities to include (CRITICAL, HIGH, MEDIUM, LOW)
            scan_type: Scan type (all, os, library)

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning image: {image}")

        if not self.check_trivy():
            logger.error("[X] Trivy not found. Install: https://aquasecurity.github.io/trivy/")
            return {}

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        image_safe = image.replace('/', '_').replace(':', '_')
        output_json = self.output_dir / f"trivy_{image_safe}_{timestamp}.json"

        # Build Trivy command
        cmd = [
            'trivy',
            'image',
            '--format', 'json',
            '--output', str(output_json)
        ]

        # Add severity filter
        if severity:
            cmd.extend(['--severity', ','.join(severity)])

        # Add scan type
        if scan_type != 'all':
            cmd.extend(['--scanners', scan_type])

        cmd.append(image)

        logger.info(f"[i] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600  # 10 minute timeout
            )

            if result.returncode == 0:
                logger.info("[OK] Scan completed successfully")

                # Load and parse results
                with open(output_json, 'r') as f:
                    scan_results = json.load(f)

                # Enhance results with summary
                enhanced_results = self._enhance_results(scan_results, image)

                # Save enhanced results
                with open(output_json, 'w') as f:
                    json.dump(enhanced_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {output_json}")
                return enhanced_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except subprocess.TimeoutExpired:
            logger.error("[X] Scan timed out (10 minutes)")
            return {}
        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def scan_filesystem(self, path: str) -> Dict:
        """
        Scan filesystem for vulnerabilities (IaC, secrets, misconfigurations)

        Args:
            path: Path to scan

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning filesystem: {path}")

        if not self.check_trivy():
            logger.error("[X] Trivy not found")
            return {}

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        path_safe = Path(path).name
        output_json = self.output_dir / f"trivy_fs_{path_safe}_{timestamp}.json"

        cmd = [
            'trivy',
            'fs',
            '--format', 'json',
            '--output', str(output_json),
            '--scanners', 'vuln,secret,config',
            path
        ]

        logger.info(f"[i] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600
            )

            if result.returncode == 0:
                with open(output_json, 'r') as f:
                    scan_results = json.load(f)

                enhanced_results = self._enhance_results(scan_results, path)

                with open(output_json, 'w') as f:
                    json.dump(enhanced_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {output_json}")
                return enhanced_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def _enhance_results(self, results: Dict, target: str) -> Dict:
        """
        Enhance scan results with summary and metadata

        Args:
            results: Raw Trivy results
            target: Scan target

        Returns:
            dict: Enhanced results
        """
        enhanced = {
            'metadata': {
                'timestamp': datetime.now().isoformat(),
                'scanner': 'trivy',
                'target': target
            },
            'summary': {
                'total_vulnerabilities': 0,
                'severity_counts': {
                    'CRITICAL': 0,
                    'HIGH': 0,
                    'MEDIUM': 0,
                    'LOW': 0,
                    'UNKNOWN': 0
                },
                'fixable': 0,
                'packages_affected': set()
            },
            'results': results.get('Results', [])
        }

        # Calculate summary
        for result in enhanced['results']:
            for vuln in result.get('Vulnerabilities', []):
                enhanced['summary']['total_vulnerabilities'] += 1

                severity = vuln.get('Severity', 'UNKNOWN')
                enhanced['summary']['severity_counts'][severity] = \
                    enhanced['summary']['severity_counts'].get(severity, 0) + 1

                if vuln.get('FixedVersion'):
                    enhanced['summary']['fixable'] += 1

                pkg_name = vuln.get('PkgName')
                if pkg_name:
                    enhanced['summary']['packages_affected'].add(pkg_name)

        # Convert set to list for JSON serialization
        enhanced['summary']['packages_affected'] = list(enhanced['summary']['packages_affected'])

        return enhanced

    def generate_report(self, results: Dict, output_file: Path) -> None:
        """
        Generate human-readable report

        Args:
            results: Scan results
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("Container Vulnerability Scan Report\n")
                f.write("="*70 + "\n\n")

                metadata = results.get('metadata', {})
                f.write(f"Target: {metadata.get('target', 'N/A')}\n")
                f.write(f"Scanner: {metadata.get('scanner', 'trivy')}\n")
                f.write(f"Timestamp: {metadata.get('timestamp', 'N/A')}\n\n")

                summary = results.get('summary', {})
                f.write("Summary:\n")
                f.write(f"  Total Vulnerabilities: {summary.get('total_vulnerabilities', 0)}\n")
                f.write(f"  Fixable: {summary.get('fixable', 0)}\n")
                f.write(f"  Packages Affected: {len(summary.get('packages_affected', []))}\n\n")

                severity_counts = summary.get('severity_counts', {})
                f.write("Severity Breakdown:\n")
                for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN']:
                    count = severity_counts.get(severity, 0)
                    if count > 0:
                        f.write(f"  {severity}: {count}\n")

                f.write("\n")
                f.write("="*70 + "\n")
                f.write("Vulnerability Details\n")
                f.write("="*70 + "\n\n")

                # Group vulnerabilities by severity
                for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                    vulns_of_severity = []

                    for result in results.get('results', []):
                        target_name = result.get('Target', 'Unknown')

                        for vuln in result.get('Vulnerabilities', []):
                            if vuln.get('Severity') == severity:
                                vulns_of_severity.append({
                                    'target': target_name,
                                    'vuln': vuln
                                })

                    if not vulns_of_severity:
                        continue

                    f.write(f"\n[{severity}] - {len(vulns_of_severity)} vulnerabilities\n")
                    f.write("-"*70 + "\n")

                    for item in vulns_of_severity[:20]:  # Limit to top 20 per severity
                        vuln = item['vuln']
                        f.write(f"\nVulnerability ID: {vuln.get('VulnerabilityID', 'N/A')}\n")
                        f.write(f"Package: {vuln.get('PkgName', 'N/A')} {vuln.get('InstalledVersion', '')}\n")

                        if vuln.get('FixedVersion'):
                            f.write(f"Fixed Version: {vuln['FixedVersion']}\n")

                        f.write(f"Title: {vuln.get('Title', 'N/A')}\n")

                        if vuln.get('Description'):
                            desc = vuln['Description'][:200] + "..." if len(vuln['Description']) > 200 else vuln['Description']
                            f.write(f"Description: {desc}\n")

                        if vuln.get('References'):
                            f.write(f"References: {vuln['References'][0]}\n")

                        f.write("-"*70 + "\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")


def main():
    parser = argparse.ArgumentParser(description='Container vulnerability scanner')
    parser.add_argument('--image', help='Container image to scan')
    parser.add_argument('--filesystem', help='Filesystem path to scan')
    parser.add_argument('--output', type=Path, default=Path('container_scans'),
                        help='Output directory')
    parser.add_argument('--severity', help='Severity filter (comma-separated: CRITICAL,HIGH,MEDIUM,LOW)')
    parser.add_argument('--scan-type', choices=['all', 'os', 'library'], default='all',
                        help='Scan type')
    parser.add_argument('--report', action='store_true', help='Generate text report')

    args = parser.parse_args()

    if not args.image and not args.filesystem:
        logger.error("[X] Image or filesystem required. Use --image or --filesystem")
        parser.print_help()
        return 1

    scanner = ContainerScanner(args.output)

    # Parse severity filter
    severity = args.severity.split(',') if args.severity else None

    # Scan
    results = None
    if args.image:
        results = scanner.scan_image(args.image, severity, args.scan_type)
    elif args.filesystem:
        results = scanner.scan_filesystem(args.filesystem)

    # Generate report if requested
    if results and args.report:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        target_safe = (args.image or args.filesystem).replace('/', '_').replace(':', '_')
        report_file = args.output / f"trivy_report_{target_safe}_{timestamp}.txt"
        scanner.generate_report(results, report_file)

    return 0 if results else 1


if __name__ == '__main__':
    exit(main())
