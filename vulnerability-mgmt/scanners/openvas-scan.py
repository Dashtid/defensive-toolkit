#!/usr/bin/env python3
"""
OpenVAS/GVM Vulnerability Scanner Integration
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Integrates with OpenVAS/GVM (Greenbone Vulnerability Manager) to perform
    automated vulnerability scans. Supports scan templates, authentication,
    and report generation.

Requirements:
    - python-gvm (pip install python-gvm)
    - OpenVAS/GVM server accessible
    - Python 3.8+

Usage:
    python openvas-scan.py --target 192.168.1.0/24 --output scan_results/
    python openvas-scan.py --target example.com --scan-type full --output results/
    python openvas-scan.py --target-file targets.txt --credentials admin:password --output scans/
"""

import argparse
import json
import logging
import os
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    from gvm.connections import UnixSocketConnection, TLSConnection
    from gvm.protocols.gmp import Gmp
    from gvm.transforms import EtreeTransform
    GVM_AVAILABLE = True
except ImportError:
    GVM_AVAILABLE = False
    logging.warning("python-gvm not available. Install: pip install python-gvm")

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class OpenVASScanner:
    """OpenVAS/GVM vulnerability scanner integration"""

    def __init__(self, host: str = None, username: str = None, password: str = None):
        self.host = host or os.environ.get('GVM_HOST', '/run/gvmd/gvmd.sock')
        self.username = username or os.environ.get('GVM_USERNAME', 'admin')
        self.password = password or os.environ.get('GVM_PASSWORD')
        self.connection = None
        self.gmp = None

        if not self.password:
            logger.error("[X] GVM password required. Set GVM_PASSWORD env var or use --credentials")
            sys.exit(1)

    def connect(self) -> bool:
        """
        Connect to GVM server

        Returns:
            bool: True if connected successfully
        """
        logger.info("[+] Connecting to GVM...")

        try:
            # Try Unix socket first (local connection)
            if self.host.startswith('/'):
                self.connection = UnixSocketConnection(path=self.host)
            else:
                # TLS connection for remote GVM
                host_parts = self.host.split(':')
                hostname = host_parts[0]
                port = int(host_parts[1]) if len(host_parts) > 1 else 9390

                self.connection = TLSConnection(hostname=hostname, port=port)

            transform = EtreeTransform()
            self.gmp = Gmp(connection=self.connection, transform=transform)

            # Authenticate
            self.gmp.authenticate(self.username, self.password)
            logger.info("[OK] Connected to GVM successfully")
            return True

        except Exception as e:
            logger.error(f"[X] Failed to connect to GVM: {e}")
            return False

    def get_scan_configs(self) -> List[Dict]:
        """
        Get available scan configurations

        Returns:
            list: Available scan configs
        """
        logger.info("[+] Fetching scan configurations...")

        try:
            response = self.gmp.get_scan_configs()
            configs = []

            for config in response.xpath('config'):
                configs.append({
                    'id': config.get('id'),
                    'name': config.find('name').text,
                    'type': config.find('type').text if config.find('type') is not None else 'unknown'
                })

            logger.info(f"[OK] Found {len(configs)} scan configurations")
            return configs

        except Exception as e:
            logger.error(f"[X] Error fetching scan configs: {e}")
            return []

    def create_target(self, name: str, hosts: str, port_list_id: str = None) -> Optional[str]:
        """
        Create scan target

        Args:
            name: Target name
            hosts: Target hosts (IP, range, or hostname)
            port_list_id: Port list UUID (optional)

        Returns:
            str: Target UUID
        """
        logger.info(f"[+] Creating target: {name}")

        try:
            # Get default port list if not specified
            if not port_list_id:
                port_lists = self.gmp.get_port_lists()
                # Use "All TCP and Nmap top 100 UDP" as default
                for port_list in port_lists.xpath('port_list'):
                    if 'All TCP' in port_list.find('name').text:
                        port_list_id = port_list.get('id')
                        break

            response = self.gmp.create_target(name=name, hosts=[hosts], port_list_id=port_list_id)
            target_id = response.get('id')

            logger.info(f"[OK] Target created: {target_id}")
            return target_id

        except Exception as e:
            logger.error(f"[X] Error creating target: {e}")
            return None

    def create_task(self, name: str, target_id: str, scan_config_id: str, scanner_id: str = None) -> Optional[str]:
        """
        Create scan task

        Args:
            name: Task name
            target_id: Target UUID
            scan_config_id: Scan config UUID
            scanner_id: Scanner UUID (optional)

        Returns:
            str: Task UUID
        """
        logger.info(f"[+] Creating scan task: {name}")

        try:
            # Get default scanner if not specified
            if not scanner_id:
                scanners = self.gmp.get_scanners()
                for scanner in scanners.xpath('scanner'):
                    if scanner.find('name').text == 'OpenVAS Default':
                        scanner_id = scanner.get('id')
                        break

            response = self.gmp.create_task(
                name=name,
                config_id=scan_config_id,
                target_id=target_id,
                scanner_id=scanner_id
            )
            task_id = response.get('id')

            logger.info(f"[OK] Task created: {task_id}")
            return task_id

        except Exception as e:
            logger.error(f"[X] Error creating task: {e}")
            return None

    def start_task(self, task_id: str) -> bool:
        """
        Start scan task

        Args:
            task_id: Task UUID

        Returns:
            bool: True if started successfully
        """
        logger.info(f"[+] Starting scan task: {task_id}")

        try:
            self.gmp.start_task(task_id)
            logger.info("[OK] Scan task started")
            return True

        except Exception as e:
            logger.error(f"[X] Error starting task: {e}")
            return False

    def get_task_status(self, task_id: str) -> Dict:
        """
        Get task status

        Args:
            task_id: Task UUID

        Returns:
            dict: Task status information
        """
        try:
            response = self.gmp.get_task(task_id)
            task = response.find('task')

            if task is None:
                return {'status': 'unknown', 'progress': 0}

            status_elem = task.find('status')
            progress_elem = task.find('progress')

            status = status_elem.text if status_elem is not None else 'unknown'
            progress = int(progress_elem.text) if progress_elem is not None else 0

            return {
                'status': status,
                'progress': progress,
                'name': task.find('name').text if task.find('name') is not None else 'unknown'
            }

        except Exception as e:
            logger.error(f"[X] Error getting task status: {e}")
            return {'status': 'error', 'progress': 0}

    def wait_for_task(self, task_id: str, check_interval: int = 30) -> bool:
        """
        Wait for task to complete

        Args:
            task_id: Task UUID
            check_interval: Status check interval (seconds)

        Returns:
            bool: True if completed successfully
        """
        logger.info("[+] Waiting for scan to complete...")

        while True:
            status_info = self.get_task_status(task_id)
            status = status_info['status']
            progress = status_info['progress']

            logger.info(f"    Status: {status} - Progress: {progress}%")

            if status == 'Done':
                logger.info("[OK] Scan completed successfully")
                return True
            elif status in ['Stopped', 'Interrupted']:
                logger.error(f"[X] Scan {status.lower()}")
                return False

            time.sleep(check_interval)

    def get_results(self, task_id: str) -> List[Dict]:
        """
        Get scan results

        Args:
            task_id: Task UUID

        Returns:
            list: Vulnerability results
        """
        logger.info("[+] Fetching scan results...")

        try:
            response = self.gmp.get_results(task_id=task_id)
            results = []

            for result in response.xpath('result'):
                threat = result.find('threat').text if result.find('threat') is not None else 'Unknown'

                # Skip log entries and false positives
                if threat in ['Log', 'False Positive']:
                    continue

                results.append({
                    'id': result.get('id'),
                    'name': result.find('name').text if result.find('name') is not None else '',
                    'host': result.find('host').text if result.find('host') is not None else '',
                    'port': result.find('port').text if result.find('port') is not None else '',
                    'threat': threat,
                    'severity': float(result.find('severity').text) if result.find('severity') is not None else 0.0,
                    'description': result.find('description').text if result.find('description') is not None else '',
                    'nvt': {
                        'oid': result.find('nvt').get('oid') if result.find('nvt') is not None else '',
                        'cvss_base': result.find('nvt/cvss_base').text if result.find('nvt/cvss_base') is not None else '',
                        'cve': result.find('nvt/refs/ref[@type="cve"]').get('id') if result.find('nvt/refs/ref[@type="cve"]') is not None else ''
                    }
                })

            logger.info(f"[OK] Retrieved {len(results)} vulnerabilities")
            return results

        except Exception as e:
            logger.error(f"[X] Error fetching results: {e}")
            return []

    def export_report(self, task_id: str, output_file: Path, format: str = 'json') -> bool:
        """
        Export scan report

        Args:
            task_id: Task UUID
            output_file: Output file path
            format: Report format (json, xml, pdf, html)

        Returns:
            bool: True if exported successfully
        """
        logger.info(f"[+] Exporting report to: {output_file}")

        try:
            if format == 'json':
                # Get results and save as JSON
                results = self.get_results(task_id)

                report_data = {
                    'timestamp': datetime.now().isoformat(),
                    'task_id': task_id,
                    'total_vulnerabilities': len(results),
                    'severity_summary': {
                        'critical': len([r for r in results if r['severity'] >= 9.0]),
                        'high': len([r for r in results if 7.0 <= r['severity'] < 9.0]),
                        'medium': len([r for r in results if 4.0 <= r['severity'] < 7.0]),
                        'low': len([r for r in results if 0.1 <= r['severity'] < 4.0])
                    },
                    'vulnerabilities': results
                }

                with open(output_file, 'w') as f:
                    json.dump(report_data, f, indent=2)

            else:
                # Use GVM report formats
                report_format_id = self._get_report_format_id(format)
                if not report_format_id:
                    logger.error(f"[X] Unsupported format: {format}")
                    return False

                response = self.gmp.get_report(task_id=task_id, report_format_id=report_format_id)
                report_content = response.find('report').text

                with open(output_file, 'wb') as f:
                    f.write(report_content.encode())

            logger.info(f"[OK] Report exported successfully")
            return True

        except Exception as e:
            logger.error(f"[X] Error exporting report: {e}")
            return False

    def _get_report_format_id(self, format: str) -> Optional[str]:
        """Get report format UUID"""
        format_map = {
            'xml': 'a994b278-1f62-11e1-96ac-406186ea4fc5',
            'pdf': 'c402cc3e-b531-11e1-9163-406186ea4fc5',
            'html': '6c248850-1f62-11e1-b082-406186ea4fc5'
        }
        return format_map.get(format)

    def disconnect(self):
        """Disconnect from GVM"""
        if self.connection:
            self.connection.disconnect()
            logger.info("[+] Disconnected from GVM")


def main():
    parser = argparse.ArgumentParser(description='OpenVAS/GVM vulnerability scanner')
    parser.add_argument('--target', help='Target host(s) to scan')
    parser.add_argument('--target-file', type=Path, help='File with target list')
    parser.add_argument('--output', type=Path, default=Path('scan_results'), help='Output directory')
    parser.add_argument('--scan-type', choices=['quick', 'full', 'discovery'], default='full',
                        help='Scan type')
    parser.add_argument('--host', help='GVM host (default: Unix socket or env GVM_HOST)')
    parser.add_argument('--credentials', help='GVM credentials (username:password)')
    parser.add_argument('--wait', action='store_true', help='Wait for scan to complete')
    parser.add_argument('--format', choices=['json', 'xml', 'pdf', 'html'], default='json',
                        help='Report format')

    args = parser.parse_args()

    if not GVM_AVAILABLE:
        logger.error("[X] python-gvm not installed. Install: pip install python-gvm")
        return 1

    if not args.target and not args.target_file:
        logger.error("[X] Target required. Use --target or --target-file")
        parser.print_help()
        return 1

    # Parse credentials
    username = None
    password = None
    if args.credentials:
        parts = args.credentials.split(':', 1)
        username = parts[0]
        password = parts[1] if len(parts) > 1 else None

    # Create output directory
    args.output.mkdir(parents=True, exist_ok=True)

    # Initialize scanner
    scanner = OpenVASScanner(host=args.host, username=username, password=password)

    if not scanner.connect():
        return 1

    try:
        # Get scan configs
        configs = scanner.get_scan_configs()

        # Select config based on scan type
        config_map = {
            'quick': 'Discovery',
            'full': 'Full and fast',
            'discovery': 'Host Discovery'
        }

        config_name = config_map.get(args.scan_type, 'Full and fast')
        scan_config_id = next((c['id'] for c in configs if config_name.lower() in c['name'].lower()), configs[0]['id'])

        # Get targets
        targets = []
        if args.target:
            targets.append(args.target)
        if args.target_file:
            with open(args.target_file, 'r') as f:
                targets.extend([line.strip() for line in f if line.strip()])

        # Scan each target
        for target_hosts in targets:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            target_name = f"scan_{target_hosts.replace('/', '_')}_{timestamp}"

            # Create target
            target_id = scanner.create_target(target_name, target_hosts)
            if not target_id:
                continue

            # Create task
            task_id = scanner.create_task(target_name, target_id, scan_config_id)
            if not task_id:
                continue

            # Start scan
            if not scanner.start_task(task_id):
                continue

            # Wait if requested
            if args.wait:
                if scanner.wait_for_task(task_id):
                    # Export results
                    output_file = args.output / f"{target_name}.{args.format}"
                    scanner.export_report(task_id, output_file, args.format)
            else:
                logger.info(f"[i] Scan started. Task ID: {task_id}")
                logger.info(f"[i] Check status with: gvm-cli --gmp-username admin --gmp-password <pass> socket get-task {task_id}")

    finally:
        scanner.disconnect()

    return 0


if __name__ == '__main__':
    exit(main())
