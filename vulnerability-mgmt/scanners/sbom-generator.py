#!/usr/bin/env python3
"""
SBOM (Software Bill of Materials) Generator
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Generates Software Bill of Materials (SBOM) in CycloneDX or SPDX format
    using syft. Complies with CISA 2025 minimum elements for SBOM.

Requirements:
    - syft installed (https://github.com/anchore/syft)
    - Python 3.8+

Usage:
    python sbom-generator.py --image nginx:latest --output sboms/
    python sbom-generator.py --directory /path/to/app --format spdx-json --output sboms/
    python sbom-generator.py --image myapp:1.0 --output sboms/ --analyze
"""

import argparse
import json
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class SBOMGenerator:
    """SBOM generator using syft"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def check_syft(self) -> bool:
        """
        Check if syft is installed

        Returns:
            bool: True if syft is available
        """
        try:
            result = subprocess.run(['syft', 'version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def generate_sbom(self, target: str, target_type: str = 'image',
                     format: str = 'cyclonedx-json') -> Optional[Path]:
        """
        Generate SBOM for target

        Args:
            target: Target to scan (image name or directory path)
            target_type: Type of target ('image' or 'directory')
            format: Output format (cyclonedx-json, cyclonedx-xml, spdx-json, spdx-tag-value)

        Returns:
            Path: Path to generated SBOM file
        """
        logger.info(f"[+] Generating SBOM for: {target}")

        if not self.check_syft():
            logger.error("[X] syft not found. Install: https://github.com/anchore/syft")
            return None

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        target_safe = target.replace('/', '_').replace(':', '_')

        # Determine file extension
        ext_map = {
            'cyclonedx-json': 'cdx.json',
            'cyclonedx-xml': 'cdx.xml',
            'spdx-json': 'spdx.json',
            'spdx-tag-value': 'spdx'
        }
        ext = ext_map.get(format, 'json')

        output_file = self.output_dir / f"sbom_{target_safe}_{timestamp}.{ext}"

        # Build syft command
        if target_type == 'image':
            syft_target = target
        else:
            syft_target = f"dir:{target}"

        cmd = [
            'syft',
            syft_target,
            '--output', f"{format}={output_file}"
        ]

        logger.info(f"[i] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )

            if result.returncode == 0:
                logger.info(f"[OK] SBOM generated: {output_file}")
                return output_file

            else:
                logger.error(f"[X] SBOM generation failed: {result.stderr}")
                return None

        except subprocess.TimeoutExpired:
            logger.error("[X] SBOM generation timed out (5 minutes)")
            return None
        except Exception as e:
            logger.error(f"[X] Error generating SBOM: {e}")
            return None

    def analyze_sbom(self, sbom_file: Path) -> Dict:
        """
        Analyze SBOM contents

        Args:
            sbom_file: Path to SBOM file

        Returns:
            dict: Analysis results
        """
        logger.info(f"[+] Analyzing SBOM: {sbom_file}")

        try:
            with open(sbom_file, 'r') as f:
                if sbom_file.suffix == '.json':
                    sbom_data = json.load(f)
                else:
                    logger.warning("[!] Non-JSON SBOM analysis not fully supported")
                    return {}

            # Detect SBOM format
            if 'bomFormat' in sbom_data and sbom_data['bomFormat'] == 'CycloneDX':
                return self._analyze_cyclonedx(sbom_data)
            elif 'spdxVersion' in sbom_data:
                return self._analyze_spdx(sbom_data)
            else:
                logger.error("[X] Unknown SBOM format")
                return {}

        except Exception as e:
            logger.error(f"[X] Error analyzing SBOM: {e}")
            return {}

    def _analyze_cyclonedx(self, sbom_data: Dict) -> Dict:
        """Analyze CycloneDX SBOM"""
        analysis = {
            'format': 'CycloneDX',
            'spec_version': sbom_data.get('specVersion', 'unknown'),
            'timestamp': sbom_data.get('metadata', {}).get('timestamp', 'unknown'),
            'components': {
                'total': 0,
                'by_type': {},
                'with_licenses': 0,
                'with_vulnerabilities': 0
            },
            'licenses': set(),
            'top_components': []
        }

        components = sbom_data.get('components', [])
        analysis['components']['total'] = len(components)

        for component in components:
            # Count by type
            comp_type = component.get('type', 'unknown')
            analysis['components']['by_type'][comp_type] = \
                analysis['components']['by_type'].get(comp_type, 0) + 1

            # Track licenses
            licenses = component.get('licenses', [])
            if licenses:
                analysis['components']['with_licenses'] += 1
                for license_info in licenses:
                    if 'license' in license_info:
                        license_id = license_info['license'].get('id') or license_info['license'].get('name')
                        if license_id:
                            analysis['licenses'].add(license_id)

            # Add to top components
            analysis['top_components'].append({
                'name': component.get('name', 'unknown'),
                'version': component.get('version', 'unknown'),
                'type': comp_type,
                'purl': component.get('purl', '')
            })

        # Convert set to list
        analysis['licenses'] = list(analysis['licenses'])

        # Limit top components
        analysis['top_components'] = analysis['top_components'][:50]

        return analysis

    def _analyze_spdx(self, sbom_data: Dict) -> Dict:
        """Analyze SPDX SBOM"""
        analysis = {
            'format': 'SPDX',
            'spec_version': sbom_data.get('spdxVersion', 'unknown'),
            'created': sbom_data.get('creationInfo', {}).get('created', 'unknown'),
            'packages': {
                'total': 0,
                'with_licenses': 0
            },
            'licenses': set(),
            'top_packages': []
        }

        packages = sbom_data.get('packages', [])
        analysis['packages']['total'] = len(packages)

        for package in packages:
            # Track licenses
            license_concluded = package.get('licenseConcluded')
            license_declared = package.get('licenseDeclared')

            if license_concluded and license_concluded != 'NOASSERTION':
                analysis['packages']['with_licenses'] += 1
                analysis['licenses'].add(license_concluded)

            if license_declared and license_declared != 'NOASSERTION':
                analysis['licenses'].add(license_declared)

            # Add to top packages
            analysis['top_packages'].append({
                'name': package.get('name', 'unknown'),
                'version': package.get('versionInfo', 'unknown'),
                'supplier': package.get('supplier', 'unknown')
            })

        # Convert set to list
        analysis['licenses'] = list(analysis['licenses'])

        # Limit top packages
        analysis['top_packages'] = analysis['top_packages'][:50]

        return analysis

    def generate_report(self, analysis: Dict, output_file: Path) -> None:
        """
        Generate SBOM analysis report

        Args:
            analysis: Analysis results
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, 'w') as f:
                f.write("="*70 + "\n")
                f.write("SBOM Analysis Report\n")
                f.write("="*70 + "\n\n")

                f.write(f"Format: {analysis.get('format', 'unknown')}\n")
                f.write(f"Spec Version: {analysis.get('spec_version', 'unknown')}\n")
                f.write(f"Generated: {analysis.get('timestamp', analysis.get('created', 'unknown'))}\n\n")

                # Component/Package summary
                if 'components' in analysis:
                    comp = analysis['components']
                    f.write("Components Summary:\n")
                    f.write(f"  Total Components: {comp.get('total', 0)}\n")
                    f.write(f"  With Licenses: {comp.get('with_licenses', 0)}\n\n")

                    if comp.get('by_type'):
                        f.write("  Components by Type:\n")
                        for comp_type, count in sorted(comp['by_type'].items(), key=lambda x: x[1], reverse=True):
                            f.write(f"    {comp_type}: {count}\n")
                        f.write("\n")

                elif 'packages' in analysis:
                    pkg = analysis['packages']
                    f.write("Packages Summary:\n")
                    f.write(f"  Total Packages: {pkg.get('total', 0)}\n")
                    f.write(f"  With Licenses: {pkg.get('with_licenses', 0)}\n\n")

                # Licenses
                licenses = analysis.get('licenses', [])
                if licenses:
                    f.write(f"Licenses Found ({len(licenses)}):\n")
                    for license_name in sorted(licenses)[:20]:
                        f.write(f"  - {license_name}\n")
                    if len(licenses) > 20:
                        f.write(f"  ... and {len(licenses) - 20} more\n")
                    f.write("\n")

                # Top components/packages
                f.write("="*70 + "\n")
                f.write("Top 20 Components/Packages\n")
                f.write("="*70 + "\n\n")

                items = analysis.get('top_components', analysis.get('top_packages', []))
                for i, item in enumerate(items[:20], 1):
                    f.write(f"{i}. {item.get('name', 'unknown')} ({item.get('version', 'unknown')})\n")
                    if item.get('type'):
                        f.write(f"   Type: {item['type']}\n")
                    if item.get('purl'):
                        f.write(f"   PURL: {item['purl']}\n")
                    if item.get('supplier'):
                        f.write(f"   Supplier: {item['supplier']}\n")
                    f.write("\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")

    def validate_cisa_compliance(self, sbom_file: Path) -> Dict:
        """
        Validate SBOM against CISA 2025 minimum elements

        Args:
            sbom_file: Path to SBOM file

        Returns:
            dict: Validation results
        """
        logger.info("[+] Validating CISA 2025 minimum elements...")

        # CISA 2025 minimum elements
        required_fields = {
            'Supplier Name': False,
            'Component Name': False,
            'Version': False,
            'Unique Identifier': False,
            'Dependency Relationships': False,
            'Author of SBOM Data': False,
            'Timestamp': False
        }

        try:
            with open(sbom_file, 'r') as f:
                sbom_data = json.load(f)

            # Check CycloneDX format
            if sbom_data.get('bomFormat') == 'CycloneDX':
                metadata = sbom_data.get('metadata', {})
                components = sbom_data.get('components', [])

                # Check timestamp
                if metadata.get('timestamp'):
                    required_fields['Timestamp'] = True

                # Check author
                if metadata.get('authors') or metadata.get('supplier'):
                    required_fields['Author of SBOM Data'] = True

                # Check component fields
                if components:
                    sample_comp = components[0]
                    if sample_comp.get('supplier') or sample_comp.get('publisher'):
                        required_fields['Supplier Name'] = True
                    if sample_comp.get('name'):
                        required_fields['Component Name'] = True
                    if sample_comp.get('version'):
                        required_fields['Version'] = True
                    if sample_comp.get('purl') or sample_comp.get('bom-ref'):
                        required_fields['Unique Identifier'] = True

                # Check dependencies
                if sbom_data.get('dependencies'):
                    required_fields['Dependency Relationships'] = True

            compliance_score = sum(required_fields.values()) / len(required_fields) * 100

            return {
                'compliant': compliance_score == 100,
                'compliance_score': compliance_score,
                'fields': required_fields,
                'missing_fields': [k for k, v in required_fields.items() if not v]
            }

        except Exception as e:
            logger.error(f"[X] Error validating SBOM: {e}")
            return {
                'compliant': False,
                'compliance_score': 0,
                'error': str(e)
            }


def main():
    parser = argparse.ArgumentParser(description='SBOM generator and analyzer')
    parser.add_argument('--image', help='Container image to scan')
    parser.add_argument('--directory', help='Directory path to scan')
    parser.add_argument('--output', type=Path, default=Path('sboms'), help='Output directory')
    parser.add_argument('--format', choices=['cyclonedx-json', 'cyclonedx-xml', 'spdx-json', 'spdx-tag-value'],
                        default='cyclonedx-json', help='SBOM format')
    parser.add_argument('--analyze', action='store_true', help='Analyze generated SBOM')
    parser.add_argument('--validate-cisa', action='store_true',
                        help='Validate against CISA 2025 minimum elements')

    args = parser.parse_args()

    if not args.image and not args.directory:
        logger.error("[X] Image or directory required. Use --image or --directory")
        parser.print_help()
        return 1

    generator = SBOMGenerator(args.output)

    # Determine target type
    target = args.image if args.image else args.directory
    target_type = 'image' if args.image else 'directory'

    # Generate SBOM
    sbom_file = generator.generate_sbom(target, target_type, args.format)

    if not sbom_file:
        return 1

    # Analyze if requested
    if args.analyze and sbom_file.suffix == '.json':
        analysis = generator.analyze_sbom(sbom_file)

        if analysis:
            # Generate report
            report_file = sbom_file.parent / f"{sbom_file.stem}_analysis.txt"
            generator.generate_report(analysis, report_file)

            # Save analysis JSON
            analysis_json = sbom_file.parent / f"{sbom_file.stem}_analysis.json"
            with open(analysis_json, 'w') as f:
                json.dump(analysis, f, indent=2)

    # Validate CISA compliance
    if args.validate_cisa and sbom_file.suffix == '.json':
        validation = generator.validate_cisa_compliance(sbom_file)

        logger.info("\n[+] CISA 2025 Compliance Check")
        logger.info(f"    Compliance Score: {validation['compliance_score']:.1f}%")
        logger.info(f"    Compliant: {validation['compliant']}")

        if validation.get('missing_fields'):
            logger.warning(f"    Missing Fields: {', '.join(validation['missing_fields'])}")

    return 0


if __name__ == '__main__':
    exit(main())
