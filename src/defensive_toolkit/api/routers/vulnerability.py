"""
Vulnerability Management API Router

Provides endpoints for vulnerability scanning using OpenVAS, Trivy, and nmap,
plus risk scoring, threat intel enrichment, and SBOM generation.

Author: Defensive Toolkit
Date: 2025-12-28
"""

import logging
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field

from defensive_toolkit.api.dependencies import (
    get_current_active_user,
    require_write_scope,
)
from defensive_toolkit.api.models import (
    APIResponse,
    StatusEnum,
    VulnerabilityScanRequest,
    VulnerabilityScanResult,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/vulnerability", tags=["Vulnerability Management"])


# ============================================================================
# Request/Response Models
# ============================================================================


class OpenVASScanRequest(BaseModel):
    """Request to start OpenVAS scan"""

    target: str = Field(..., description="Target IP, CIDR, or hostname")
    scan_type: str = Field(
        "discovery", pattern="^(discovery|quick|full)$", description="Scan template type"
    )
    port_list: Optional[str] = Field(None, description="Port list ID (optional)")


class ContainerScanRequest(BaseModel):
    """Request to scan container image"""

    image: str = Field(..., description="Docker image name (e.g., nginx:latest)")
    severity: str = Field(
        "MEDIUM", pattern="^(CRITICAL|HIGH|MEDIUM|LOW|UNKNOWN)$", description="Minimum severity"
    )
    scan_type: str = Field(
        "vuln", pattern="^(vuln|config|secret|license)$", description="Trivy scan type"
    )


class NetworkScanRequest(BaseModel):
    """Request for nmap vulnerability scan"""

    target: str = Field(..., description="Target IP or hostname")
    quick: bool = Field(True, description="Quick scan (common ports) vs full scan")
    ports: Optional[str] = Field(None, description="Custom port range (e.g., 22,80,443)")


class SBOMGenerateRequest(BaseModel):
    """Request to generate SBOM"""

    target: str = Field(..., description="Target path or image")
    target_type: str = Field(
        "dir", pattern="^(dir|image|file)$", description="Target type"
    )
    format: str = Field(
        "cyclonedx-json",
        pattern="^(cyclonedx-json|spdx-json|syft-json)$",
        description="SBOM format",
    )


class SBOMAnalyzeRequest(BaseModel):
    """Request to analyze SBOM"""

    sbom_file: str = Field(..., description="Path to SBOM file")


class RiskScoreRequest(BaseModel):
    """Request to score vulnerabilities"""

    vulnerabilities: List[Dict[str, Any]] = Field(
        ..., description="List of vulnerability objects"
    )
    asset_criticality: str = Field(
        "medium", pattern="^(critical|high|medium|low)$", description="Asset criticality"
    )
    environment: str = Field(
        "production",
        pattern="^(production|staging|development)$",
        description="Environment type",
    )


class EnrichRequest(BaseModel):
    """Request to enrich vulnerabilities with threat intel"""

    vulnerabilities: List[Dict[str, Any]] = Field(
        ..., description="List of vulnerability objects with CVE IDs"
    )


class ScanStatusResponse(BaseModel):
    """Response for scan status"""

    task_id: str
    status: str
    progress: Optional[int] = None
    name: Optional[str] = None


# ============================================================================
# Helper Functions
# ============================================================================


def get_openvas_scanner():
    """Get OpenVAS scanner instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.openvas_scan import (
            OpenVASScanner,
        )

        return OpenVASScanner()
    except ImportError as e:
        logger.error(f"Failed to import OpenVASScanner: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="OpenVAS scanner module not available",
        )
    except SystemExit:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="OpenVAS configuration error: GVM_PASSWORD not set",
        )


def get_container_scanner():
    """Get container scanner instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.container_scan import (
            ContainerScanner,
        )

        scanner = ContainerScanner()
        if not scanner.check_trivy():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Trivy is not installed or not in PATH",
            )
        return scanner
    except ImportError as e:
        logger.error(f"Failed to import ContainerScanner: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Container scanner module not available",
        )


def get_nmap_scanner():
    """Get nmap vulnerability scanner instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.nmap_vuln_scan import (
            NmapVulnScanner,
        )

        scanner = NmapVulnScanner()
        if not scanner.check_nmap():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="nmap is not installed or not in PATH",
            )
        return scanner
    except ImportError as e:
        logger.error(f"Failed to import NmapVulnScanner: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Nmap scanner module not available",
        )


def get_sbom_generator():
    """Get SBOM generator instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.sbom_generator import (
            SBOMGenerator,
        )

        generator = SBOMGenerator()
        if not generator.check_syft():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="syft is not installed or not in PATH",
            )
        return generator
    except ImportError as e:
        logger.error(f"Failed to import SBOMGenerator: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="SBOM generator module not available",
        )


def get_risk_scorer():
    """Get risk scorer instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.prioritization.risk_scorer import (
            RiskScorer,
        )

        return RiskScorer()
    except ImportError as e:
        logger.error(f"Failed to import RiskScorer: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Risk scorer module not available",
        )


def get_threat_enricher():
    """Get threat intel enricher instance"""
    try:
        from defensive_toolkit.vulnerability_mgmt.prioritization.threat_intel_enrichment import (
            ThreatIntelEnricher,
        )

        return ThreatIntelEnricher()
    except ImportError as e:
        logger.error(f"Failed to import ThreatIntelEnricher: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Threat intel enricher module not available",
        )


# ============================================================================
# OpenVAS Scanning Endpoints
# ============================================================================


@router.post("/scan/openvas", response_model=Dict[str, Any])
async def start_openvas_scan(
    request: OpenVASScanRequest,
    current_user: str = Depends(require_write_scope),
):
    """
    Start an OpenVAS vulnerability scan.

    Requires GVM_PASSWORD environment variable to be set.
    Returns task_id for polling scan status.
    """
    try:
        scanner = get_openvas_scanner()

        if not scanner.connect():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Failed to connect to OpenVAS/GVM server",
            )

        # Get scan config based on type
        configs = scanner.get_scan_configs()
        config_id = None
        for config in configs:
            if request.scan_type.lower() in config.get("name", "").lower():
                config_id = config.get("id")
                break

        if not config_id and configs:
            config_id = configs[0].get("id")  # Default to first config

        # Create target
        target_id = scanner.create_target(
            name=f"API-{request.target}-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}",
            hosts=request.target,
            port_list_id=request.port_list,
        )

        # Create and start task
        task_id = scanner.create_task(
            name=f"API-Scan-{request.target}",
            target_id=target_id,
            config_id=config_id,
        )

        scanner.start_task(task_id)

        return {
            "task_id": task_id,
            "target": request.target,
            "scan_type": request.scan_type,
            "status": "started",
            "message": f"Scan started. Poll /vulnerability/scan/{task_id}/status for progress.",
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"OpenVAS scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start OpenVAS scan: {str(e)}",
        )


@router.get("/scan/{task_id}/status", response_model=ScanStatusResponse)
async def get_scan_status(
    task_id: str,
    current_user: str = Depends(get_current_active_user),
):
    """
    Get status of an OpenVAS scan.

    Returns status and progress percentage.
    """
    try:
        scanner = get_openvas_scanner()

        if not scanner.connect():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Failed to connect to OpenVAS/GVM server",
            )

        status_info = scanner.get_task_status(task_id)

        return ScanStatusResponse(
            task_id=task_id,
            status=status_info.get("status", "unknown"),
            progress=status_info.get("progress"),
            name=status_info.get("name"),
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get scan status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get scan status: {str(e)}",
        )


@router.get("/scan/{task_id}/results", response_model=Dict[str, Any])
async def get_scan_results(
    task_id: str,
    current_user: str = Depends(get_current_active_user),
):
    """
    Get results of a completed OpenVAS scan.
    """
    try:
        scanner = get_openvas_scanner()

        if not scanner.connect():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Failed to connect to OpenVAS/GVM server",
            )

        results = scanner.get_results(task_id)

        # Calculate summary
        summary = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for vuln in results:
            severity = vuln.get("severity", 0)
            if severity >= 9.0:
                summary["critical"] += 1
            elif severity >= 7.0:
                summary["high"] += 1
            elif severity >= 4.0:
                summary["medium"] += 1
            else:
                summary["low"] += 1

        return {
            "task_id": task_id,
            "vulnerability_count": len(results),
            "summary": summary,
            "vulnerabilities": results,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get scan results: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get scan results: {str(e)}",
        )


# ============================================================================
# Container Scanning Endpoints
# ============================================================================


@router.post("/scan/container", response_model=Dict[str, Any])
async def scan_container_image(
    request: ContainerScanRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Scan a Docker container image for vulnerabilities using Trivy.
    """
    try:
        scanner = get_container_scanner()

        results = scanner.scan_image(
            image=request.image,
            severity=request.severity,
            scan_type=request.scan_type,
        )

        return {
            "scan_id": str(uuid.uuid4()),
            "image": request.image,
            "scan_type": request.scan_type,
            "results": results,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Container scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Container scan failed: {str(e)}",
        )


# ============================================================================
# Network Scanning Endpoints
# ============================================================================


@router.post("/scan/network", response_model=Dict[str, Any])
async def scan_network_vulnerabilities(
    request: NetworkScanRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Run nmap NSE vulnerability scan on target.
    """
    try:
        scanner = get_nmap_scanner()

        results = scanner.scan_vulnerabilities(
            target=request.target,
            quick=request.quick,
            ports=request.ports,
        )

        return {
            "scan_id": str(uuid.uuid4()),
            "target": request.target,
            "quick_scan": request.quick,
            "results": results,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Network scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Network scan failed: {str(e)}",
        )


# ============================================================================
# SBOM Endpoints
# ============================================================================


@router.post("/sbom/generate", response_model=Dict[str, Any])
async def generate_sbom(
    request: SBOMGenerateRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Generate Software Bill of Materials (SBOM) for a target.

    Supports CycloneDX, SPDX, and syft-json formats.
    """
    try:
        generator = get_sbom_generator()

        sbom_data = generator.generate_sbom(
            target=request.target,
            target_type=request.target_type,
            format=request.format,
        )

        return {
            "sbom_id": str(uuid.uuid4()),
            "target": request.target,
            "format": request.format,
            "sbom": sbom_data,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"SBOM generation failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"SBOM generation failed: {str(e)}",
        )


@router.post("/sbom/analyze", response_model=Dict[str, Any])
async def analyze_sbom(
    request: SBOMAnalyzeRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Analyze an SBOM file for component inventory and vulnerabilities.
    """
    try:
        if not Path(request.sbom_file).exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"SBOM file not found: {request.sbom_file}",
            )

        generator = get_sbom_generator()
        analysis = generator.analyze_sbom(request.sbom_file)

        return {
            "sbom_file": request.sbom_file,
            "analysis": analysis,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"SBOM analysis failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"SBOM analysis failed: {str(e)}",
        )


@router.post("/sbom/validate-cisa", response_model=Dict[str, Any])
async def validate_cisa_compliance(
    request: SBOMAnalyzeRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Validate SBOM against CISA 2025 requirements.
    """
    try:
        if not Path(request.sbom_file).exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"SBOM file not found: {request.sbom_file}",
            )

        generator = get_sbom_generator()
        validation = generator.validate_cisa_compliance(request.sbom_file)

        return {
            "sbom_file": request.sbom_file,
            "validation": validation,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"CISA validation failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"CISA validation failed: {str(e)}",
        )


# ============================================================================
# Risk Scoring Endpoints
# ============================================================================


@router.post("/score", response_model=Dict[str, Any])
async def score_vulnerabilities(
    request: RiskScoreRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Score vulnerabilities using multi-factor risk analysis.

    Combines CVSS, KEV catalog, EPSS scores, asset criticality,
    and threat intelligence for comprehensive prioritization.
    """
    try:
        scorer = get_risk_scorer()

        # Load KEV catalog for enrichment
        scorer.load_kev_catalog()

        scored = scorer.score_vulnerabilities(
            vulns=request.vulnerabilities,
            asset_criticality=request.asset_criticality,
            environment=request.environment,
        )

        # Calculate summary
        priority_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
        for vuln in scored:
            priority = vuln.get("priority", "LOW")
            priority_counts[priority] = priority_counts.get(priority, 0) + 1

        return {
            "total_vulnerabilities": len(scored),
            "priority_summary": priority_counts,
            "scored_vulnerabilities": scored,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Risk scoring failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Risk scoring failed: {str(e)}",
        )


@router.post("/enrich", response_model=Dict[str, Any])
async def enrich_vulnerabilities(
    request: EnrichRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Enrich vulnerabilities with threat intelligence.

    Adds KEV status, NVD data, and exploit information.
    """
    try:
        enricher = get_threat_enricher()
        enricher.load_kev()

        enriched = enricher.enrich_vulnerabilities(request.vulnerabilities)

        return {
            "total_vulnerabilities": len(enriched),
            "enriched_vulnerabilities": enriched,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Enrichment failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Vulnerability enrichment failed: {str(e)}",
        )


@router.get("/kev/{cve_id}", response_model=Dict[str, Any])
async def check_kev_status(
    cve_id: str,
    current_user: str = Depends(get_current_active_user),
):
    """
    Check if a CVE is in the CISA KEV (Known Exploited Vulnerabilities) catalog.
    """
    try:
        scorer = get_risk_scorer()
        scorer.load_kev_catalog()

        in_kev = scorer.check_kev(cve_id.upper())

        return {
            "cve_id": cve_id.upper(),
            "in_kev_catalog": in_kev,
            "message": "Vulnerability is actively exploited - prioritize remediation"
            if in_kev
            else "Not in KEV catalog",
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"KEV check failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"KEV check failed: {str(e)}",
        )


# ============================================================================
# Statistics & Summary Endpoints
# ============================================================================


@router.get("/stats", response_model=Dict[str, Any])
async def get_vulnerability_stats(
    current_user: str = Depends(get_current_active_user),
):
    """
    Get aggregated vulnerability statistics.

    Returns summary of scans, severity distribution, and trends.
    """
    # This would pull from stored scan results
    return {
        "last_updated": datetime.utcnow().isoformat(),
        "total_scans": 0,
        "total_vulnerabilities": 0,
        "by_severity": {"critical": 0, "high": 0, "medium": 0, "low": 0},
        "message": "Run scans to populate statistics",
    }


@router.get("/scanners", response_model=List[Dict[str, str]])
async def list_available_scanners(
    current_user: str = Depends(get_current_active_user),
):
    """
    List available vulnerability scanners and their status.
    """
    scanners = []

    # Check OpenVAS
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.openvas_scan import (
            GVM_AVAILABLE,
        )

        scanners.append(
            {
                "name": "OpenVAS/GVM",
                "type": "network",
                "status": "available" if GVM_AVAILABLE else "unavailable",
                "description": "Enterprise vulnerability scanner",
            }
        )
    except ImportError:
        scanners.append(
            {"name": "OpenVAS/GVM", "type": "network", "status": "not_installed"}
        )

    # Check Trivy
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.container_scan import (
            ContainerScanner,
        )

        scanner = ContainerScanner()
        scanners.append(
            {
                "name": "Trivy",
                "type": "container",
                "status": "available" if scanner.check_trivy() else "unavailable",
                "description": "Container and filesystem vulnerability scanner",
            }
        )
    except Exception:
        scanners.append({"name": "Trivy", "type": "container", "status": "not_installed"})

    # Check nmap
    try:
        from defensive_toolkit.vulnerability_mgmt.scanners.nmap_vuln_scan import (
            NmapVulnScanner,
        )

        scanner = NmapVulnScanner()
        scanners.append(
            {
                "name": "nmap",
                "type": "network",
                "status": "available" if scanner.check_nmap() else "unavailable",
                "description": "Network vulnerability scanner with NSE scripts",
            }
        )
    except Exception:
        scanners.append({"name": "nmap", "type": "network", "status": "not_installed"})

    return scanners


# ============================================================================
# Legacy Endpoints (backwards compatibility)
# ============================================================================


@router.post("/scan", response_model=VulnerabilityScanResult)
async def scan_target(
    request: VulnerabilityScanRequest,
    current_user: str = Depends(get_current_active_user),
):
    """
    Legacy endpoint - Scan target for vulnerabilities.

    Use /scan/openvas, /scan/container, or /scan/network for more options.
    """
    # Default to network scan with nmap
    try:
        scanner = get_nmap_scanner()
        results = scanner.scan_vulnerabilities(
            target=request.target,
            quick=request.scan_type == "quick",
        )

        # Convert to legacy format
        vulnerabilities = []
        summary = {"critical": 0, "high": 0, "medium": 0, "low": 0}

        for host_results in results.get("hosts", []):
            for vuln in host_results.get("vulnerabilities", []):
                vulnerabilities.append(vuln)
                severity = vuln.get("severity", "low").lower()
                if severity in summary:
                    summary[severity] += 1

        return VulnerabilityScanResult(
            scan_id=str(uuid.uuid4()),
            target=request.target,
            scan_type=request.scan_type,
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            vulnerabilities=vulnerabilities,
            summary=summary,
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Scan failed: {e}")
        # Fallback to mock response
        return VulnerabilityScanResult(
            scan_id=str(uuid.uuid4()),
            target=request.target,
            scan_type=request.scan_type,
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            vulnerabilities=[],
            summary={"critical": 0, "high": 0, "medium": 0, "low": 0},
        )


@router.get("/scans/{scan_id}", response_model=VulnerabilityScanResult)
async def get_scan_result(
    scan_id: str,
    current_user: str = Depends(get_current_active_user),
):
    """
    Legacy endpoint - Get vulnerability scan results.

    Use /scan/{task_id}/results for OpenVAS scans.
    """
    return VulnerabilityScanResult(
        scan_id=scan_id,
        target="unknown",
        scan_type="quick",
        start_time=datetime.utcnow(),
        end_time=datetime.utcnow(),
        vulnerabilities=[],
        summary={"critical": 0, "high": 0, "medium": 0, "low": 0},
    )
