#!/usr/bin/env python3
"""
Threat Intelligence Enrichment for Vulnerabilities
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Enriches vulnerability data with threat intelligence from:
    - CISA KEV catalog
    - NVD (National Vulnerability Database)
    - Exploit-DB searches
    - Public exploit availability

Requirements:
    - requests (pip install requests)
    - Python 3.8+

Usage:
    python threat-intel-enrichment.py --vulnerabilities vulns.json --output enriched.json
    python threat-intel-enrichment.py --cve CVE-2021-44228 --output log4j_intel.json
"""

import argparse
import json
import logging
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    import requests

    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")
logger = logging.getLogger(__name__)


class ThreatIntelEnricher:
    """Enrich vulnerabilities with threat intelligence"""

    def __init__(self):
        self.kev_catalog = None
        self.nvd_cache = {}
        self.session = requests.Session() if REQUESTS_AVAILABLE else None

    def load_kev(self) -> bool:
        """Load CISA KEV catalog"""
        logger.info("[+] Loading CISA KEV catalog...")

        try:
            response = self.session.get(
                "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
                timeout=30,
            )
            self.kev_catalog = response.json()
            logger.info(
                f"[OK] Loaded {len(self.kev_catalog.get('vulnerabilities', []))} KEV entries"
            )
            return True
        except Exception as e:
            logger.error(f"[X] KEV load failed: {e}")
            return False

    def get_kev_details(self, cve_id: str) -> Optional[Dict]:
        """Get KEV catalog details for CVE"""
        if not self.kev_catalog:
            return None

        for vuln in self.kev_catalog.get("vulnerabilities", []):
            if vuln.get("cveID", "").upper() == cve_id.upper():
                return {
                    "in_kev": True,
                    "date_added": vuln.get("dateAdded"),
                    "due_date": vuln.get("dueDate"),
                    "known_ransomware": vuln.get("knownRansomwareCampaignUse", "Unknown"),
                    "notes": vuln.get("notes", ""),
                }
        return {"in_kev": False}

    def query_nvd(self, cve_id: str) -> Optional[Dict]:
        """Query NVD for CVE details"""
        if cve_id in self.nvd_cache:
            return self.nvd_cache[cve_id]

        logger.info(f"[+] Querying NVD for {cve_id}...")

        try:
            response = self.session.get(
                "https://services.nvd.nist.gov/rest/json/cves/2.0",
                params={"cveId": cve_id},
                timeout=10,
            )

            if response.status_code == 200:
                data = response.json()
                if data.get("vulnerabilities"):
                    cve_item = data["vulnerabilities"][0]["cve"]
                    nvd_data = {
                        "description": cve_item.get("descriptions", [{}])[0].get("value", ""),
                        "published": cve_item.get("published"),
                        "references": [
                            ref.get("url") for ref in cve_item.get("references", [])[:5]
                        ],
                        "cvss_v3": None,
                        "cvss_v2": None,
                    }

                    # Extract CVSS scores
                    metrics = cve_item.get("metrics", {})
                    if "cvssMetricV31" in metrics:
                        cvss_v3 = metrics["cvssMetricV31"][0]["cvssData"]
                        nvd_data["cvss_v3"] = cvss_v3.get("baseScore")
                    if "cvssMetricV2" in metrics:
                        cvss_v2 = metrics["cvssMetricV2"][0]["cvssData"]
                        nvd_data["cvss_v2"] = cvss_v2.get("baseScore")

                    self.nvd_cache[cve_id] = nvd_data
                    time.sleep(0.6)  # Rate limit: 5 requests per 30 seconds
                    return nvd_data

            return None

        except Exception as e:
            logger.warning(f"[!] NVD query failed for {cve_id}: {e}")
            return None

    def check_exploits(self, cve_id: str, references: List[str] = None) -> Dict:
        """Check for public exploits"""
        exploit_sources = {
            "exploit-db": False,
            "metasploit": False,
            "github_poc": False,
            "references_with_exploit": [],
        }

        if references:
            refs_str = " ".join(references).lower()
            exploit_sources["exploit-db"] = "exploit-db" in refs_str
            exploit_sources["metasploit"] = "metasploit" in refs_str
            exploit_sources["github_poc"] = "github.com" in refs_str and (
                "poc" in refs_str or "exploit" in refs_str
            )

            exploit_sources["references_with_exploit"] = [
                ref
                for ref in references
                if any(keyword in ref.lower() for keyword in ["exploit", "poc", "metasploit"])
            ]

        return exploit_sources

    def enrich_vulnerability(self, vuln: Dict) -> Dict:
        """Enrich single vulnerability with threat intel"""
        # Extract CVE ID
        cve_id = None
        for field in ["cve", "cveID", "VulnerabilityID", "id"]:
            if field in vuln:
                cve_value = str(vuln[field])
                if cve_value.upper().startswith("CVE-"):
                    cve_id = cve_value.upper()
                    break

        if not cve_id:
            return vuln

        enriched = vuln.copy()
        enriched["threat_intelligence"] = {}

        # KEV enrichment
        kev_details = self.get_kev_details(cve_id)
        if kev_details:
            enriched["threat_intelligence"]["kev"] = kev_details

        # NVD enrichment
        nvd_data = self.query_nvd(cve_id)
        if nvd_data:
            enriched["threat_intelligence"]["nvd"] = nvd_data

        # Exploit enrichment
        references = vuln.get("references", vuln.get("References", []))
        if isinstance(references, list) and references:
            exploit_info = self.check_exploits(cve_id, references)
            enriched["threat_intelligence"]["exploits"] = exploit_info

        return enriched

    def enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enrich all vulnerabilities"""
        logger.info(f"[+] Enriching {len(vulnerabilities)} vulnerabilities...")

        enriched = []
        for i, vuln in enumerate(vulnerabilities, 1):
            if i % 10 == 0:
                logger.info(f"    Progress: {i}/{len(vulnerabilities)}")

            enriched_vuln = self.enrich_vulnerability(vuln)
            enriched.append(enriched_vuln)

        logger.info("[OK] Enrichment complete")
        return enriched


def main():
    parser = argparse.ArgumentParser(description="Threat intelligence enrichment")
    parser.add_argument("--vulnerabilities", type=Path, help="Vulnerability JSON file")
    parser.add_argument("--cve", help="Single CVE to enrich")
    parser.add_argument("--output", type=Path, required=True, help="Output JSON file")

    args = parser.parse_args()

    if not REQUESTS_AVAILABLE:
        logger.error("[X] requests library required. Install: pip install requests")
        return 1

    if not args.vulnerabilities and not args.cve:
        logger.error("[X] Either --vulnerabilities or --cve required")
        return 1

    enricher = ThreatIntelEnricher()
    enricher.load_kev()

    if args.cve:
        # Enrich single CVE
        vuln = {"cve": args.cve}
        enriched = enricher.enrich_vulnerability(vuln)

        with open(args.output, "w") as f:
            json.dump(enriched, f, indent=2)

        logger.info(f"[OK] Saved to: {args.output}")

    else:
        # Enrich vulnerability list
        with open(args.vulnerabilities, "r") as f:
            data = json.load(f)

        if isinstance(data, list):
            vulns = data
        elif "vulnerabilities" in data:
            vulns = data["vulnerabilities"]
        else:
            logger.error("[X] Unsupported format")
            return 1

        enriched = enricher.enrich_vulnerabilities(vulns)

        with open(args.output, "w") as f:
            json.dump(
                {
                    "metadata": {"timestamp": datetime.now().isoformat()},
                    "vulnerabilities": enriched,
                },
                f,
                indent=2,
            )

        logger.info(f"[OK] Saved to: {args.output}")

    return 0


if __name__ == "__main__":
    exit(main())
