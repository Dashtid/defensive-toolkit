#!/usr/bin/env python3
"""
Nmap NSE Vulnerability Scanner
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Automated Nmap vulnerability scanning using NSE (Nmap Scripting Engine).
    Runs vulnerability detection scripts and formats results for analysis.

Requirements:
    - nmap installed on system
    - python-nmap (pip install python-nmap)
    - Python 3.8+

Usage:
    python nmap-vuln-scan.py --target 192.168.1.100 --output results/
    python nmap-vuln-scan.py --target 10.0.0.0/24 --quick --output scan/
    python nmap-vuln-scan.py --target-file hosts.txt --output scans/
"""

import argparse
import json
import logging
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
from pathlib import Path
from typing import Dict, List

try:
    import nmap

    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False
    logging.warning("python-nmap not available. Install: pip install python-nmap")

logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")
logger = logging.getLogger(__name__)


class NmapVulnScanner:
    """Nmap NSE vulnerability scanner"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.nm = nmap.PortScanner() if NMAP_AVAILABLE else None

    def check_nmap(self) -> bool:
        """
        Check if nmap is installed

        Returns:
            bool: True if nmap is available
        """
        try:
            result = subprocess.run(["nmap", "--version"], capture_output=True, timeout=5)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def scan_vulnerabilities(self, target: str, quick: bool = False, ports: str = None) -> Dict:
        """
        Scan target for vulnerabilities using NSE scripts

        Args:
            target: Target host or network
            quick: Quick scan (fewer scripts)
            ports: Port specification (default: common ports)

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning target: {target}")

        if not self.check_nmap():
            logger.error("[X] nmap not found. Install: apt install nmap")
            return {}

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_base = self.output_dir / f"nmap_vuln_{target.replace('/', '_')}_{timestamp}"

        # Build nmap command
        if quick:
            # Quick scan - common vulnerabilities
            scripts = "vuln,exploit"
            scan_ports = ports or "21-23,25,80,110,139,143,443,445,3306,3389,8080"
        else:
            # Full scan - comprehensive vulnerability checks
            scripts = "vuln,exploit,discovery,auth,brute"
            scan_ports = ports or "1-1000"

        nmap_args = [
            "nmap",
            "-sV",  # Service version detection
            "--script",
            scripts,
            "-p",
            scan_ports,
            "-oX",
            f"{output_base}.xml",
            "-oN",
            f"{output_base}.txt",
            target,
        ]

        logger.info(f"[i] Running: {' '.join(nmap_args)}")

        try:
            result = subprocess.run(
                nmap_args, capture_output=True, text=True, timeout=3600  # 1 hour timeout
            )

            if result.returncode == 0:
                logger.info("[OK] Scan completed successfully")

                # Parse XML output
                scan_results = self.parse_xml_results(f"{output_base}.xml")

                # Save JSON report
                json_output = f"{output_base}.json"
                with open(json_output, "w") as f:
                    json.dump(scan_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {json_output}")
                return scan_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except subprocess.TimeoutExpired:
            logger.error("[X] Scan timed out (1 hour)")
            return {}
        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def parse_xml_results(self, xml_file: Path) -> Dict:
        """
        Parse nmap XML output

        Args:
            xml_file: Path to XML file

        Returns:
            dict: Parsed results
        """
        logger.info("[+] Parsing scan results...")

        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()

            results = {
                "timestamp": datetime.now().isoformat(),
                "scanner": "nmap",
                "scan_info": {},
                "hosts": [],
            }

            # Parse scan info
            scaninfo = root.find("scaninfo")
            if scaninfo is not None:
                results["scan_info"] = {
                    "type": scaninfo.get("type"),
                    "protocol": scaninfo.get("protocol"),
                    "services": scaninfo.get("services"),
                }

            # Parse hosts
            for host in root.findall("host"):
                host_data = self._parse_host(host)
                if host_data:
                    results["hosts"].append(host_data)

            # Generate summary
            total_vulns = sum(len(h.get("vulnerabilities", [])) for h in results["hosts"])
            results["summary"] = {
                "total_hosts": len(results["hosts"]),
                "total_vulnerabilities": total_vulns,
                "hosts_with_vulns": len([h for h in results["hosts"] if h.get("vulnerabilities")]),
            }

            logger.info(
                f"[OK] Found {total_vulns} vulnerabilities across {len(results['hosts'])} hosts"
            )
            return results

        except Exception as e:
            logger.error(f"[X] Error parsing XML: {e}")
            return {}

    def _parse_host(self, host_elem) -> Dict:
        """Parse host element from XML"""
        host_data = {
            "status": (
                host_elem.find("status").get("state")
                if host_elem.find("status") is not None
                else "unknown"
            ),
            "addresses": [],
            "hostnames": [],
            "ports": [],
            "vulnerabilities": [],
        }

        # Parse addresses
        for addr in host_elem.findall("address"):
            host_data["addresses"].append({"addr": addr.get("addr"), "type": addr.get("addrtype")})

        # Parse hostnames
        hostnames_elem = host_elem.find("hostnames")
        if hostnames_elem is not None:
            for hostname in hostnames_elem.findall("hostname"):
                host_data["hostnames"].append(
                    {"name": hostname.get("name"), "type": hostname.get("type")}
                )

        # Parse ports
        ports_elem = host_elem.find("ports")
        if ports_elem is not None:
            for port in ports_elem.findall("port"):
                port_data = self._parse_port(port)
                if port_data:
                    host_data["ports"].append(port_data)

                    # Extract vulnerabilities from scripts
                    script_vulns = self._extract_vulnerabilities(port)
                    host_data["vulnerabilities"].extend(script_vulns)

        return host_data

    def _parse_port(self, port_elem) -> Dict:
        """Parse port element"""
        port_data = {
            "port": port_elem.get("portid"),
            "protocol": port_elem.get("protocol"),
            "state": (
                port_elem.find("state").get("state")
                if port_elem.find("state") is not None
                else "unknown"
            ),
        }

        # Parse service info
        service = port_elem.find("service")
        if service is not None:
            port_data["service"] = {
                "name": service.get("name"),
                "product": service.get("product"),
                "version": service.get("version"),
                "extrainfo": service.get("extrainfo"),
            }

        return port_data

    def _extract_vulnerabilities(self, port_elem) -> List[Dict]:
        """Extract vulnerabilities from NSE scripts"""
        vulnerabilities = []

        for script in port_elem.findall("script"):
            script_id = script.get("id")
            script_output = script.get("output", "")

            # Check if this is a vulnerability-related script
            if any(keyword in script_id for keyword in ["vuln", "exploit", "cve", "dos"]):
                # Try to extract CVE IDs
                cves = self._extract_cves(script_output)

                vuln = {
                    "script": script_id,
                    "port": port_elem.get("portid"),
                    "description": script_output.strip(),
                    "cves": cves,
                    "severity": self._estimate_severity(script_id, script_output),
                }

                vulnerabilities.append(vuln)

        return vulnerabilities

    def _extract_cves(self, text: str) -> List[str]:
        """Extract CVE IDs from text"""
        import re

        cve_pattern = r"CVE-\d{4}-\d{4,7}"
        return list(set(re.findall(cve_pattern, text, re.IGNORECASE)))

    def _estimate_severity(self, script_id: str, output: str) -> str:
        """Estimate vulnerability severity based on keywords"""
        output_lower = output.lower()
        script_lower = script_id.lower()

        # High severity indicators
        if any(
            keyword in output_lower or keyword in script_lower
            for keyword in ["exploit", "remote code execution", "rce", "critical", "dangerous"]
        ):
            return "high"

        # Medium severity indicators
        if any(
            keyword in output_lower or keyword in script_lower
            for keyword in ["vulnerable", "injection", "disclosure", "bypass"]
        ):
            return "medium"

        # Low severity
        return "low"

    def generate_report(self, results: Dict, output_file: Path) -> None:
        """
        Generate human-readable report

        Args:
            results: Scan results
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, "w") as f:
                f.write("=" * 70 + "\n")
                f.write("Nmap Vulnerability Scan Report\n")
                f.write("=" * 70 + "\n\n")

                f.write(f"Timestamp: {results.get('timestamp', 'N/A')}\n")
                f.write(f"Scanner: {results.get('scanner', 'nmap')}\n\n")

                summary = results.get("summary", {})
                f.write("Summary:\n")
                f.write(f"  Total Hosts: {summary.get('total_hosts', 0)}\n")
                f.write(f"  Hosts with Vulnerabilities: {summary.get('hosts_with_vulns', 0)}\n")
                f.write(f"  Total Vulnerabilities: {summary.get('total_vulnerabilities', 0)}\n\n")

                # Host details
                f.write("=" * 70 + "\n")
                f.write("Host Details\n")
                f.write("=" * 70 + "\n\n")

                for host in results.get("hosts", []):
                    if not host.get("vulnerabilities"):
                        continue

                    # Host header
                    ip = host["addresses"][0]["addr"] if host.get("addresses") else "Unknown"
                    f.write(f"\nHost: {ip}\n")
                    f.write("-" * 70 + "\n")

                    # Vulnerabilities
                    for vuln in host["vulnerabilities"]:
                        f.write(
                            f"\n[{vuln['severity'].upper()}] Port {vuln['port']} - {vuln['script']}\n"
                        )
                        if vuln.get("cves"):
                            f.write(f"CVEs: {', '.join(vuln['cves'])}\n")
                        f.write(f"Description:\n{vuln['description']}\n")
                        f.write("-" * 70 + "\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")


def main():
    parser = argparse.ArgumentParser(description="Nmap NSE vulnerability scanner")
    parser.add_argument("--target", help="Target host or network")
    parser.add_argument("--target-file", type=Path, help="File with target list")
    parser.add_argument("--output", type=Path, default=Path("nmap_scans"), help="Output directory")
    parser.add_argument("--quick", action="store_true", help="Quick scan (fewer scripts)")
    parser.add_argument("--ports", help="Port specification (e.g., 80,443,8080 or 1-1000)")

    args = parser.parse_args()

    if not NMAP_AVAILABLE:
        logger.warning("[!] python-nmap not available. Falling back to direct nmap execution.")

    if not args.target and not args.target_file:
        logger.error("[X] Target required. Use --target or --target-file")
        parser.print_help()
        return 1

    scanner = NmapVulnScanner(args.output)

    # Get targets
    targets = []
    if args.target:
        targets.append(args.target)
    if args.target_file:
        with open(args.target_file, "r") as f:
            targets.extend([line.strip() for line in f if line.strip()])

    # Scan each target
    for target in targets:
        results = scanner.scan_vulnerabilities(target, args.quick, args.ports)

        if results:
            # Generate text report
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = args.output / f"nmap_report_{target.replace('/', '_')}_{timestamp}.txt"
            scanner.generate_report(results, report_file)

    return 0


if __name__ == "__main__":
    exit(main())
