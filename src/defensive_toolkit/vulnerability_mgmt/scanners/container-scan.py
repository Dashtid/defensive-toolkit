#!/usr/bin/env python3
"""
Container and Image Vulnerability Scanner
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Scans Docker containers and images for vulnerabilities using Trivy.
    Supports scanning local images, registries, and running containers.

Requirements:
    - Trivy installed (https://aquasecurity.github.io/trivy/)
    - Python 3.8+

Usage:
    python container-scan.py --image nginx:latest --output results/
    python container-scan.py --image myapp:1.0 --severity HIGH,CRITICAL
    python container-scan.py --registry myregistry.azurecr.io/app:latest --output scans/
"""

import argparse
import json
import logging
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List

logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")
logger = logging.getLogger(__name__)


class ContainerScanner:
    """Container vulnerability scanner using Trivy"""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def check_trivy(self) -> bool:
        """
        Check if Trivy is installed

        Returns:
            bool: True if Trivy is available
        """
        try:
            result = subprocess.run(["trivy", "--version"], capture_output=True, timeout=5)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def scan_image(self, image: str, severity: List[str] = None, scan_type: str = "all") -> Dict:
        """
        Scan container image for vulnerabilities

        Args:
            image: Image name (e.g., nginx:latest)
            severity: List of severities to include (CRITICAL, HIGH, MEDIUM, LOW)
            scan_type: Scan type (all, os, library)

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning image: {image}")

        if not self.check_trivy():
            logger.error("[X] Trivy not found. Install: https://aquasecurity.github.io/trivy/")
            return {}

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        image_safe = image.replace("/", "_").replace(":", "_")
        output_json = self.output_dir / f"trivy_{image_safe}_{timestamp}.json"

        # Build Trivy command
        cmd = ["trivy", "image", "--format", "json", "--output", str(output_json)]

        # Add severity filter
        if severity:
            cmd.extend(["--severity", ",".join(severity)])

        # Add scan type
        if scan_type != "all":
            cmd.extend(["--scanners", scan_type])

        cmd.append(image)

        logger.info(f"[i] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=600  # 10 minute timeout
            )

            if result.returncode == 0:
                logger.info("[OK] Scan completed successfully")

                # Load and parse results
                with open(output_json, "r") as f:
                    scan_results = json.load(f)

                # Enhance results with summary
                enhanced_results = self._enhance_results(scan_results, image)

                # Save enhanced results
                with open(output_json, "w") as f:
                    json.dump(enhanced_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {output_json}")
                return enhanced_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except subprocess.TimeoutExpired:
            logger.error("[X] Scan timed out (10 minutes)")
            return {}
        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def scan_filesystem(self, path: str) -> Dict:
        """
        Scan filesystem for vulnerabilities (IaC, secrets, misconfigurations)

        Args:
            path: Path to scan

        Returns:
            dict: Scan results
        """
        logger.info(f"[+] Scanning filesystem: {path}")

        if not self.check_trivy():
            logger.error("[X] Trivy not found")
            return {}

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        path_safe = Path(path).name
        output_json = self.output_dir / f"trivy_fs_{path_safe}_{timestamp}.json"

        cmd = [
            "trivy",
            "fs",
            "--format",
            "json",
            "--output",
            str(output_json),
            "--scanners",
            "vuln,secret,config",
            path,
        ]

        logger.info(f"[i] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)

            if result.returncode == 0:
                with open(output_json, "r") as f:
                    scan_results = json.load(f)

                enhanced_results = self._enhance_results(scan_results, path)

                with open(output_json, "w") as f:
                    json.dump(enhanced_results, f, indent=2)

                logger.info(f"[OK] Results saved to: {output_json}")
                return enhanced_results

            else:
                logger.error(f"[X] Scan failed: {result.stderr}")
                return {}

        except Exception as e:
            logger.error(f"[X] Error during scan: {e}")
            return {}

    def _enhance_results(self, results: Dict, target: str) -> Dict:
        """
        Enhance scan results with summary and metadata

        Args:
            results: Raw Trivy results
            target: Scan target

        Returns:
            dict: Enhanced results
        """
        enhanced = {
            "metadata": {
                "timestamp": datetime.now().isoformat(),
                "scanner": "trivy",
                "target": target,
            },
            "summary": {
                "total_vulnerabilities": 0,
                "severity_counts": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0},
                "fixable": 0,
                "packages_affected": set(),
            },
            "results": results.get("Results", []),
        }

        # Calculate summary
        for result in enhanced["results"]:
            for vuln in result.get("Vulnerabilities", []):
                enhanced["summary"]["total_vulnerabilities"] += 1

                severity = vuln.get("Severity", "UNKNOWN")
                enhanced["summary"]["severity_counts"][severity] = (
                    enhanced["summary"]["severity_counts"].get(severity, 0) + 1
                )

                if vuln.get("FixedVersion"):
                    enhanced["summary"]["fixable"] += 1

                pkg_name = vuln.get("PkgName")
                if pkg_name:
                    enhanced["summary"]["packages_affected"].add(pkg_name)

        # Convert set to list for JSON serialization
        enhanced["summary"]["packages_affected"] = list(enhanced["summary"]["packages_affected"])

        return enhanced

    def generate_report(self, results: Dict, output_file: Path) -> None:
        """
        Generate human-readable report

        Args:
            results: Scan results
            output_file: Output file path
        """
        logger.info(f"[+] Generating report: {output_file}")

        try:
            with open(output_file, "w") as f:
                f.write("=" * 70 + "\n")
                f.write("Container Vulnerability Scan Report\n")
                f.write("=" * 70 + "\n\n")

                metadata = results.get("metadata", {})
                f.write(f"Target: {metadata.get('target', 'N/A')}\n")
                f.write(f"Scanner: {metadata.get('scanner', 'trivy')}\n")
                f.write(f"Timestamp: {metadata.get('timestamp', 'N/A')}\n\n")

                summary = results.get("summary", {})
                f.write("Summary:\n")
                f.write(f"  Total Vulnerabilities: {summary.get('total_vulnerabilities', 0)}\n")
                f.write(f"  Fixable: {summary.get('fixable', 0)}\n")
                f.write(f"  Packages Affected: {len(summary.get('packages_affected', []))}\n\n")

                severity_counts = summary.get("severity_counts", {})
                f.write("Severity Breakdown:\n")
                for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"]:
                    count = severity_counts.get(severity, 0)
                    if count > 0:
                        f.write(f"  {severity}: {count}\n")

                f.write("\n")
                f.write("=" * 70 + "\n")
                f.write("Vulnerability Details\n")
                f.write("=" * 70 + "\n\n")

                # Group vulnerabilities by severity
                for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
                    vulns_of_severity = []

                    for result in results.get("results", []):
                        target_name = result.get("Target", "Unknown")

                        for vuln in result.get("Vulnerabilities", []):
                            if vuln.get("Severity") == severity:
                                vulns_of_severity.append({"target": target_name, "vuln": vuln})

                    if not vulns_of_severity:
                        continue

                    f.write(f"\n[{severity}] - {len(vulns_of_severity)} vulnerabilities\n")
                    f.write("-" * 70 + "\n")

                    for item in vulns_of_severity[:20]:  # Limit to top 20 per severity
                        vuln = item["vuln"]
                        f.write(f"\nVulnerability ID: {vuln.get('VulnerabilityID', 'N/A')}\n")
                        f.write(
                            f"Package: {vuln.get('PkgName', 'N/A')} {vuln.get('InstalledVersion', '')}\n"
                        )

                        if vuln.get("FixedVersion"):
                            f.write(f"Fixed Version: {vuln['FixedVersion']}\n")

                        f.write(f"Title: {vuln.get('Title', 'N/A')}\n")

                        if vuln.get("Description"):
                            desc = (
                                vuln["Description"][:200] + "..."
                                if len(vuln["Description"]) > 200
                                else vuln["Description"]
                            )
                            f.write(f"Description: {desc}\n")

                        if vuln.get("References"):
                            f.write(f"References: {vuln['References'][0]}\n")

                        f.write("-" * 70 + "\n")

            logger.info(f"[OK] Report generated: {output_file}")

        except Exception as e:
            logger.error(f"[X] Error generating report: {e}")


def main():
    parser = argparse.ArgumentParser(description="Container vulnerability scanner")
    parser.add_argument("--image", help="Container image to scan")
    parser.add_argument("--filesystem", help="Filesystem path to scan")
    parser.add_argument(
        "--output", type=Path, default=Path("container_scans"), help="Output directory"
    )
    parser.add_argument(
        "--severity", help="Severity filter (comma-separated: CRITICAL,HIGH,MEDIUM,LOW)"
    )
    parser.add_argument(
        "--scan-type", choices=["all", "os", "library"], default="all", help="Scan type"
    )
    parser.add_argument("--report", action="store_true", help="Generate text report")

    args = parser.parse_args()

    if not args.image and not args.filesystem:
        logger.error("[X] Image or filesystem required. Use --image or --filesystem")
        parser.print_help()
        return 1

    scanner = ContainerScanner(args.output)

    # Parse severity filter
    severity = args.severity.split(",") if args.severity else None

    # Scan
    results = None
    if args.image:
        results = scanner.scan_image(args.image, severity, args.scan_type)
    elif args.filesystem:
        results = scanner.scan_filesystem(args.filesystem)

    # Generate report if requested
    if results and args.report:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        target_safe = (args.image or args.filesystem).replace("/", "_").replace(":", "_")
        report_file = args.output / f"trivy_report_{target_safe}_{timestamp}.txt"
        scanner.generate_report(results, report_file)

    return 0 if results else 1


if __name__ == "__main__":
    exit(main())
