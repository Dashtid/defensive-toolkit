#!/usr/bin/env python3
"""
Memory-Based Malware Hunting
Author: Defensive Toolkit
Date: 2025-10-15

Description:
    Automated malware hunting in memory dumps using Volatility 3 and heuristics.
    Identifies suspicious processes, injections, and malicious indicators.

Requirements:
    - Volatility 3
    - Python 3.8+

Usage:
    python hunt-malware.py memory.dmp
    python hunt-malware.py memory.dmp --iocs iocs.txt
"""

import argparse
import json
import logging
import re
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Set

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class MalwareHunter:
    """Hunt for malware in memory dumps"""

    def __init__(self, memory_dump: Path, ioc_file: Path = None):
        self.memory_dump = memory_dump
        self.iocs = self._load_iocs(ioc_file) if ioc_file else {}
        self.findings = []

    def _load_iocs(self, ioc_file: Path) -> Dict:
        """Load IOCs from file"""
        logger.info(f"Loading IOCs from {ioc_file}")
        iocs = {'processes': [], 'dlls': [], 'ips': [], 'domains': []}

        with open(ioc_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                if '.exe' in line.lower() or '.dll' in line.lower():
                    iocs['processes'].append(line.lower())
                elif re.match(r'\d+\.\d+\.\d+\.\d+', line):
                    iocs['ips'].append(line)
                elif '.' in line and not line[0].isdigit():
                    iocs['domains'].append(line.lower())

        logger.info(f"Loaded {len(iocs['processes'])} process IOCs, "
                   f"{len(iocs['ips'])} IP IOCs, {len(iocs['domains'])} domain IOCs")
        return iocs

    def _run_volatility(self, plugin: str) -> str:
        """Run Volatility plugin and return output"""
        cmd = ['vol', '-f', str(self.memory_dump), plugin]
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
            return result.stdout if result.returncode == 0 else ""
        except Exception as e:
            logger.error(f"Error running {plugin}: {e}")
            return ""

    def check_suspicious_processes(self) -> None:
        """Check for suspicious process characteristics"""
        logger.info("[+] Checking for suspicious processes...")

        output = self._run_volatility('windows.pslist.PsList')
        if not output:
            return

        suspicious_names = [
            'cmd.exe', 'powershell.exe', 'pwsh.exe', 'wscript.exe', 'cscript.exe',
            'mshta.exe', 'rundll32.exe', 'regsvr32.exe', 'certutil.exe', 'bitsadmin.exe'
        ]

        for line in output.splitlines():
            line_lower = line.lower()

            # Check against known malicious process names
            for proc_name in suspicious_names:
                if proc_name in line_lower:
                    self.findings.append({
                        'type': 'Suspicious Process',
                        'severity': 'medium',
                        'description': f'Suspicious process found: {proc_name}',
                        'details': line.strip()
                    })

            # Check against IOCs
            if self.iocs.get('processes'):
                for ioc in self.iocs['processes']:
                    if ioc in line_lower:
                        self.findings.append({
                            'type': 'IOC Match - Process',
                            'severity': 'high',
                            'description': f'Known malicious process: {ioc}',
                            'details': line.strip()
                        })

            # Check for unusual parent-child relationships
            if 'explorer.exe' not in line_lower and 'powershell.exe' in line_lower:
                if 'winword.exe' in line_lower or 'excel.exe' in line_lower:
                    self.findings.append({
                        'type': 'Suspicious Parent-Child',
                        'severity': 'high',
                        'description': 'Office application spawned PowerShell',
                        'details': line.strip()
                    })

    def check_code_injection(self) -> None:
        """Check for code injection indicators"""
        logger.info("[+] Checking for code injection...")

        output = self._run_volatility('windows.malfind.Malfind')
        if not output:
            return

        injection_count = 0
        for line in output.splitlines():
            if 'MZ' in line or 'This program cannot be run' in line:
                injection_count += 1

        if injection_count > 0:
            self.findings.append({
                'type': 'Code Injection',
                'severity': 'critical',
                'description': f'Code injection detected in {injection_count} process(es)',
                'details': f'Review malfind output for details'
            })

    def check_network_connections(self) -> None:
        """Check for suspicious network connections"""
        logger.info("[+] Checking network connections...")

        output = self._run_volatility('windows.netscan.NetScan')
        if not output:
            return

        suspicious_ports = ['4444', '8080', '31337', '1337', '5555']

        for line in output.splitlines():
            # Check suspicious ports
            for port in suspicious_ports:
                if f':{port}' in line:
                    self.findings.append({
                        'type': 'Suspicious Port',
                        'severity': 'medium',
                        'description': f'Suspicious port detected: {port}',
                        'details': line.strip()
                    })

            # Check IOC IPs
            if self.iocs.get('ips'):
                for ip in self.iocs['ips']:
                    if ip in line:
                        self.findings.append({
                            'type': 'IOC Match - IP',
                            'severity': 'high',
                            'description': f'Known malicious IP: {ip}',
                            'details': line.strip()
                        })

    def check_hidden_processes(self) -> None:
        """Check for hidden/unlinked processes"""
        logger.info("[+] Checking for hidden processes...")

        pslist_output = self._run_volatility('windows.pslist.PsList')
        psscan_output = self._run_volatility('windows.psscan.PsScan')

        if not pslist_output or not psscan_output:
            return

        # Extract PIDs from both outputs
        pslist_pids = set()
        for line in pslist_output.splitlines():
            match = re.search(r'\s+(\d+)\s+', line)
            if match:
                pslist_pids.add(match.group(1))

        psscan_pids = set()
        for line in psscan_output.splitlines():
            match = re.search(r'\s+(\d+)\s+', line)
            if match:
                psscan_pids.add(match.group(1))

        hidden_pids = psscan_pids - pslist_pids
        if hidden_pids:
            self.findings.append({
                'type': 'Hidden Processes',
                'severity': 'critical',
                'description': f'Hidden/unlinked processes detected',
                'details': f'PIDs: {", ".join(sorted(hidden_pids)[:10])}'
            })

    def check_suspicious_dlls(self) -> None:
        """Check for suspicious DLL loading"""
        logger.info("[+] Checking for suspicious DLLs...")

        output = self._run_volatility('windows.ldrmodules.LdrModules')
        if not output:
            return

        unlinked_count = 0
        for line in output.splitlines():
            if 'False' in line:  # Unlinked DLL
                unlinked_count += 1

                # Check against IOCs
                if self.iocs.get('dlls'):
                    for ioc in self.iocs['dlls']:
                        if ioc.lower() in line.lower():
                            self.findings.append({
                                'type': 'IOC Match - DLL',
                                'severity': 'high',
                                'description': f'Known malicious DLL: {ioc}',
                                'details': line.strip()
                            })

        if unlinked_count > 5:  # Threshold
            self.findings.append({
                'type': 'Unlinked DLLs',
                'severity': 'medium',
                'description': f'{unlinked_count} unlinked DLLs detected',
                'details': 'Possible DLL injection or hiding technique'
            })

    def check_persistence_mechanisms(self) -> None:
        """Check for persistence mechanisms"""
        logger.info("[+] Checking for persistence mechanisms...")

        # Check registry run keys
        output = self._run_volatility('windows.registry.printkey.PrintKey --key Software\\Microsoft\\Windows\\CurrentVersion\\Run')

        suspicious_keywords = ['temp', 'appdata', 'programdata', 'users\\public', 'download']

        for line in output.splitlines():
            line_lower = line.lower()
            for keyword in suspicious_keywords:
                if keyword in line_lower and ('.exe' in line_lower or '.dll' in line_lower):
                    self.findings.append({
                        'type': 'Suspicious Persistence',
                        'severity': 'high',
                        'description': f'Suspicious registry run key found',
                        'details': line.strip()
                    })

    def generate_report(self, output_file: Path = None) -> None:
        """Generate hunting report"""
        logger.info("\n" + "="*70)
        logger.info("Malware Hunting Report")
        logger.info("="*70)

        # Group findings by severity
        critical = [f for f in self.findings if f['severity'] == 'critical']
        high = [f for f in self.findings if f['severity'] == 'high']
        medium = [f for f in self.findings if f['severity'] == 'medium']

        logger.info(f"\nFindings Summary:")
        logger.info(f"  Critical: {len(critical)}")
        logger.info(f"  High: {len(high)}")
        logger.info(f"  Medium: {len(medium)}")
        logger.info(f"  Total: {len(self.findings)}")

        if self.findings:
            logger.info(f"\n[!] Detailed Findings:\n")
            for i, finding in enumerate(self.findings, 1):
                logger.info(f"{i}. [{finding['severity'].upper()}] {finding['type']}")
                logger.info(f"   {finding['description']}")
                logger.info(f"   {finding['details']}\n")

            # Save to file
            if output_file:
                report = {
                    'timestamp': datetime.now().isoformat(),
                    'memory_dump': str(self.memory_dump),
                    'total_findings': len(self.findings),
                    'severity_counts': {
                        'critical': len(critical),
                        'high': len(high),
                        'medium': len(medium)
                    },
                    'findings': self.findings
                }

                with open(output_file, 'w') as f:
                    json.dump(report, f, indent=2)

                logger.info(f"[OK] Report saved to: {output_file}")
        else:
            logger.info("\n[OK] No obvious malware indicators found")

        logger.info("="*70)

    def hunt(self) -> None:
        """Run all hunting checks"""
        logger.info(f"Starting malware hunt on: {self.memory_dump}\n")

        self.check_suspicious_processes()
        self.check_code_injection()
        self.check_network_connections()
        self.check_hidden_processes()
        self.check_suspicious_dlls()
        self.check_persistence_mechanisms()


def main():
    parser = argparse.ArgumentParser(description='Memory-based malware hunting')
    parser.add_argument('memory_dump', type=Path, help='Memory dump file')
    parser.add_argument('--iocs', type=Path, help='IOC file (one per line)')
    parser.add_argument('--output', type=Path, help='Output JSON report')

    args = parser.parse_args()

    if not args.memory_dump.exists():
        logger.error(f"Memory dump not found: {args.memory_dump}")
        return 1

    hunter = MalwareHunter(args.memory_dump, args.iocs)
    hunter.hunt()
    hunter.generate_report(args.output)

    return 0 if not hunter.findings else 1


if __name__ == '__main__':
    exit(main())
